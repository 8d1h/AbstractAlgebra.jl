Build
-----

* Building on Windows should use binaries (building 64 bit Pari is not supported)

* Pari doesn't find libgmp.so even when told explicitly where to look because
LD_LIBRARY_PATH needs to be set. We can get around this by having Pari statically
link against libgmp.a on Linux.

* Build Pari and Arb on Windows (32 bit only)

* Use git clone rather than wget for mpir/mpfr and try/except

General
-------

* Nemo uses num/den, but for polys we are using numerator/denominator

* entry/coeff, set_entry!/set_coeff! for Residue{fmpz} entries but 
  entry_data/coeff_data, set_entry!/set_coeff! (overloaded) for Int/fmpz
  entries

* Use macro for check_parent instead of function (throughout)

* Implement strict equality, e.g. isidentical(1+O(x), 1+O(x^2)) == false;
  don't use isequal; in Julia it's for objects that hash to the same value

* Add test code

* change names of shift_left/right

* add deepcopy methods

* fix issues with stack overflow on nonexistent operators

* work out how to add /(a::Poly{T}, a::T) methods, etc, without conflicts

* implement type stable division which doesn't assume exactness

* make function names conform to Julia standard

* rename primpart to primitive_part

* add hashing for all types

* put underscore before den and num type fields, to prevent a.num instead
  of num(a)

fmpz_mod_poly.jl
----------------

* Write it

Poly.jl/fmpz_poly.jl
--------------------

* Fix printing of monomials, e.g. y + (x), y + (6)

* Fix efficient powering of x in flint specialised polynomials cases

* function to convert poly to array

* check flint pseudodivision really returns a result with the power of L as defined in the nemo docs

* check the resultant and bezout functions for flint polys work correctly for nonmonic polys

* correct description of bezout for nonmonic polys

* Should mod be defined for polys over ZZ where the divisor is monic?

* implement fmpz_mod_poly_get_str_pretty and use it in show

ZZ.jl
-----

* defining % automatically defines rem, so remove one from ZZ

* hashing of fmpz's is inefficient

Residue.jl
----------

* Make powering do its own powmod

* implement divexact by an invertible integer, etc

* Hashing of tuples doesn't do what we want, e.g.
   R = ResidueRing(ZZ, ZZ(2))
   S = ResidueRing(ZZ, ZZ(2))
   R == S
   returns false

FLINT
-----

* allow fmpq_sqrt_series to take square constant coefficient

* fix printing of parentheses in polys over finite fields

* fix issue with dll production on Windows

* document and test fq_poly_scalar_div_fq

* add fq_poly_scalar_div_ui/si/fmpz

* implement print_pretty_series (reverse order of coeffs)

* suppress printing of 1 coeffs in fmpq_poly_print_pretty

* fmpq_poly_inv_series can be faster than Sage's power series inversion

* fix isprime bug

* document and test set_exact_fmpz, add_exact, mul_exact, sub_exact, inv_exact,
  div_exact, sqrt_exact, pow_exact_si, div_exact_fmpz

* handle monomials and binomials optimally in powering, composition, division
  etc. in polynomial/power series functions (over Z, Z/nZ, Q, Fq)

PowerSeries.jl
--------------

* allow division by power series with non-invertible leading coeff if division
can still be performed

* ensure exp is only defined for rings in which division by an integer is
possible

Fraction.jl
-----------

* should Fraction only use canonical_unit when printing?

* canonical_unit for fractions is odd for (1//(x^2+1))//(2//(x+1)) over
  rationals

nf.jl
-----

* fix needs_parentheses and is_negative

pari_int.jl
-----------

* Pari integer conversion from fmpz is not efficient

pari_frac.jl
------------

* ZZ! in pari_frac.jl should not be needed, call ZZ! in pari_int 
  once Julia supports doing so

fq.jl
-----

* Allow creation of a finite field from an fmpz_mod_poly as modulus as we've
  done in fq_nmod.jl for an nmod_poly modulus

Julia bugs??
============

* Julia cleans up fq_ctx before it is passed to C function fq_poly_clear

* Overloading / for poly/coeff causes ambiguity

* Stack overflow when using the catchall in Rings.jl

* functions defined inside functions (e.g. convert in PolynomialRing) cause crashes
  if function is called multiple times with different types, because the same lines
  of code correspond to different functions

* ccall needs {S} when functions containing them are called from within other
  functions

* disambiguation required in Fraction.jl

