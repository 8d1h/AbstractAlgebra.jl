\documentclass[a4paper,10pt]{article}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{eucal}
\usepackage{amscd}
\usepackage{url}
\usepackage{hyperref}
\usepackage{color}
\usepackage{textcomp}
\usepackage{listings}
\urlstyle{sf}

\addtolength{\oddsidemargin}{-0.75in}
\addtolength{\evensidemargin}{-0.75in}
\addtolength{\textwidth}{1.5in}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Pee}{\mathbb{P}}
\newcommand{\EuO}{\mathcal{O}}
\newcommand{\Qbar}{\overline{\mathbb{Q}}}
\newcommand{\fn}{\hfill[Function]}
\newcommand{\macro}{\hfill[Macro]}
\newcommand{\gmp}{\hfill[GMP]}
\newcommand{\code}{\lstinline}
\newcommand{\desc}[1]{\vspace{-3mm}\begin{quote}#1\end{quote}}

\newcommand{\ljk}[2]{\left(\frac{#1}{#2}\right)}
\newcommand{\modulo}[1]{\;\left(\mbox{mod}\;#1\right)}
\newcommand{\fr}{\mathfrak}

\def\notdivides{\mathrel{\kern-3pt\not\!\kern4.5pt\bigm|}}
\def\nmid{\notdivides}
\def\nsubseteq{\mathrel{\kern-3pt\not\!\kern2.5pt\subseteq}}

\lstdefinelanguage{julia}
{
  keywordsprefix=\@,
  morekeywords={
    exit,whos,edit,load,is,isa,isequal,typeof,tuple,ntuple,uid,hash,finalizer,convert,promote,
    subtype,typemin,typemax,realmin,realmax,sizeof,eps,promote_type,method_exists,applicable,
    invoke,dlopen,dlsym,system,error,throw,assert,new,Inf,Nan,pi,im,begin,while,for,in,return,
    break,continue,macro,quote,let,if,elseif,else,try,catch,end,bitstype,ccall,do,using,module,
    import,export,importall,baremodule,immutable,local,global,const,Bool,Int,Int8,Int16,Int32,
    Int64,Uint,Uint8,Uint16,Uint32,Uint64,Float32,Float64,Complex64,Complex128,Any,Nothing,None,
    function,type,typealias,abstract
  },
  sensitive=true,
  morecomment=[l]{\#},
  morestring=[b]',
  morestring=[b]" 
}

\parindent=0pt
\parskip 4pt plus 2pt minus 2pt

%\email{goodwillhart@googlemail.com}

\title{Nemo : a flint interpreter}
\author{William B. Hart}

\begin{document}
\lstset{
  language=julia,
  keywordstyle=\bfseries\ttfamily\color[rgb]{0,0.6,0.4},
  identifierstyle=\ttfamily\color[rgb]{0,0.2,0.8},
  commentstyle=\color[rgb]{0.8,0.05,1},
  stringstyle=\color[rgb]{0.8,0.1,0.1},
  basicstyle=\ttfamily,
  showstringspaces=false,
}
\maketitle
\tableofcontents

\section{Introduction}

Nemo is, in the first place, an interpreter for the FLINT (Fast Library for Number Theory) project
(see \url{http://flintlib.org}). It is based on the Julia programming language
(see \url{http://julialang.org/}).

The scope of Nemo is expected to be computer algebra and number theory. As such, it is my hope that 
Nemo will eventually provide access to the Pari library (see \url{http://pari.math.u-bordeaux.fr/}),
parts of the Singular package (see \url{http://www.singular.uni-kl.de/}) and the Gap library
(see \url{http://www.gap-system.org/}).

Of course, I need to demonstrate that this is all feasible and convince a lot of people that the
project is worthwhile before that can actually happen.

\section{The Julia programming language}

I spent around four years looking for a suitable high level programming language which
can interface to the existing flint library, and provide either a flint interpreter, 
or at least a statically compiled generic layer for flint. 

I looked at a vast number of languages (well over 200), and a few times even got as far as
starting to write prototype flint wrappers to evaluate some of those languages. Many times
I also started writing a programming language myself (work continues in that direction).

In short, the perfect language does not yet exist. I believe the language I am looking
for will exist some time between 2018 and 2024.

Some statically compiled and scripting languages, such as C++, D, Rust and Nimrod provide a 
reasonable solution if all one wants is a generic layer. But they all have gotchas, (most of
which will be sorted as the languages mature).

Julia is the first language, to my knowledge, which is sufficiently good to be used as an
interpreter for flint.

\subsection{In praise of Julia}

Julia started life in 2009. It's main architects are Jeff Bezanson, Stefan Karpinski and
Viral B. Shah, though there are over 150 contributors to date.

Julia is one of the most sophisticated and technologically advanced programming languages
available today. Julia and LLVM combined, represent over a million lines of code.

Now, I don't claim Julia is one of the most complex or one of the largest programming
languages in the world. In fact, it is neither large, nor complex. But in terms of taking 
advantage of recently available technology (such as the LLVM Jit), and in terms of making 
significant innovations in programming language design, Julia is very futuristic.

Today, Julia has a good sized community, a very well fleshed out standard library, it is very
usable, sporting hundreds of contributed libraries, a package manager and even an IPython
interface.

Hundreds of thousands of lines of code have already been written in Julia. The language is
already used in production environments, including big data and parallel environments. The
Julia website gets over 150,000 visits a month. There are Julia users groups worldwide and
courses taught in Julia in at least Canada and the US.

Most importantly, Julia is designed for mathematicians.

Julia combines a number of important technologies, which I believe will play an important part
in the future of computer algebra. I outline those technologies below. To my knowledge, Julia
may be the only usable programming language available today which provides all of those
technologies. For that reason, Julia provides a great interim solution for the flint project, 
at least until 2024 rolls around.

\subsubsection{Jit compilation}

Julia uses the LLVM Jit. LLVM is a 14 year old compiler infrastructure which underlies the 
Clang C/C++ compiler and components of over a dozen other programming languages.

LLVM's chief architect is Chris Lattner, an Apple employee since 2005, now working on Apple's 
Swift programming language, which uses LLVM heavily. LLVM itself is reported to be used by Apple
for its IOS tool development. I mention this only to show that LLVM is a serious, mature, 
industry supported and hardened project, which is in turn supporting a very large ecosystem. In 
short, it isn't going away any time soon.

The LLVM Jit allows Julia to provide near C (sometimes C beating) performance, in real time.

Various other languages have a Jit with near C performance and have to run in real-time
environments, such as Javascript, Java and to some extent the Microsoft CLR languages, e.g.
C\#, F\# and VB.Net (actually, Java and the CLR languages are first statically compiled to 
bytecode).

Unlike other Jit compilers, LLVM's strategy is to provide a rich type system at the bytecode
level and to simply compile the bytecode on demand to machine code. All of the usual optimisation
passes that are available in a modern C compiler (such as Clang), can be applied to produce very
fast executable code, which can be immediately executed, in real time.

This kind of Jit compilation is ideal for mathematical code, since we generally do not care if
compilation takes as long as it takes our Enter key to rise up to its resting position after we
have pressed it. We care only about how fast our very large loops will take to execute, after
compilation has happened.

This kind of Jit compilation is not so useful for environments like a web browser, where users
really do care about how long compilation takes. (The Mono project gets around this by combining
LLVM Jit optimisation with fast code paths that avoid compilation, where this would be slower
than running interpreted code directly.)

Julia combines LLVM's Jit with dynamic type inference. This is a strategy which allows one to
combine most of the benefits of a statically typed language (such as C/C++) with the flexibility
and ease of use of dynamically typed languages (such as Python, Javascript, PHP, Perl and 
Ruby).

To the greatest extent possible, Julia tries to infer the types for each function. However, it
allows code to be written without specifying types, if one should so wish. Thus, from the user's
perspective it is dynamically typed. But in many cases, exactly the same machine code results as
would come from a C compiler and hand-written C. When all the types can be inferred, no type 
information needs to be retained at runtime. This results in execution that is often as fast as 
native C (sometimes faster).

Moreover, Julia infers types dynamically. This means that each time a function is called, type
inference goes into action, possibly meaning that a statically compiled and optimised version
can be executed directly, instead of carrying type information along throughout the 
computation.

Dynamic type inference cannot always infer types, and for this reason I am not a massive fan of
dynamic type inference. But the results are a good compromise between the flexibility of a 
dynamically typed language and the performance of statically typed languages.

\subsubsection{Interactive console}

Julia offers an interactive console, similar to Python. It can also be used from IJulia, which
is an IPython derivative, even on the web, via the IPython notebook!

The Julia console uses readline and offers an online help system.

Most importantly, Julia offers Jit compiled code at the console! You don't have to precompile
Julia statically to get C-like performance. What you type at the console executes at lightning
speed, immediately.

The console offers exception handling and recovery, pretty printing of types and values, stack 
traces, profiling and timing, the ability to disassemble the Jit compiled code, and exposes 
Julia's type inference machinery, introspection capabilities, interactive loading of modules 
and libraries (including native code) and all of the Julia language, including sophisticated 
metaprogramming features. 

\subsubsection{Foreign function interface}

Julia allows direct access to C libraries (and just recently, C++ libraries). This includes
full access to C structs and arrays.

There is a simple mapping from C types to Julia types, and wrappers do not need to be written.
Any native dynamic library (such as flint) can be directly accessed from within Julia, so long
as it is in the current library path.

There is no additional overhead in accessing native C libraries from within Julia than there
would be from a native C program using that library.

Julia also offers initialisers and finalisers, which allow memory managed C objects to 
automatically call a C initialiser on creation and a finaliser when they leave scope, similar
to the way C++ constructors and destructors work.

\subsubsection{Dependent and parametric types}

Few languages in the world sport a proper dependent and parametric type system. If they
do, it is usually at static compile time only.

The prime example of dependent types for a computer algebraist is when creating a type for
polynomials over a ring $R$. In Julia, we can provide a type called Poly, which depends on
another type, $R$ say, specifying the ring you are working over. e.g. $R$ might be the
integers, or another polynomial ring, or a ring of matrices, etc.

A type can depend on as many types as one would like.

In contrast to dependent types, the prime example of a parametric type arises for a number 
theorist when working with a number field or in $\Z/n\Z$. Elements of these rings have a
modulus (e.g. the defining polynomial of the number field, or the modulus $n$ of the residue
ring $\Z/n\Z$).

In other words, we want the type to depend on a value (here $n$), rather than another
type. Thus the type for $\Z/n\Z$ is a parametric type.

Julia doesn't quite allow types to be parameterised by arbitrary objects such as a
polynomial or an bignum integer $n$. But it does allow parameterisation by a machine
integer or a symbol (a variable name without a value attached), and this is enough.

The usefulness of this is again in performance. If the modulus $n$ is retained as part of
the type and not part of the object, then it does not have to be carried along at
runtime. 

Imagine for example a polynomial over $\Z/n\Z$. Each coefficient is an object in $\Z/n\Z$.
We can represent each such value by a pair of integers, one for the residue, one for the
modulus $n$. But in a polynomial, every coefficient will carry the same modulus $n$, which
is somehow redundant.

A more sensible approach is to make the polynomial a value of type Poly$\{\Z/n\Z\}$.
In this way, the modulus $n$ is attached to the type, not each coefficient of the
polynomial. The polynomial is then free to be represented by an array of integers, one for
each residue modulo $n$. The modulus does not need to be recorded for each coefficient of 
the polynomial. This obviously results in a factor of two space saving.

But there's a further crucial benefit. Julia is polymorphic, meaning that multiple functions
(and operators) can have the same name. For example, one can overload the $+$ operator
for polynomials over a ring. But in addition to this, one can write a specialised 
implementation for addition of polynomials over $\Z/n\Z$.

In most dynamic languages, e.g. Python, one writes a single function add(a, b), say, which
then needs many lines of code to sort out what it is adding. All of this type decision code
is executed at runtime. 

In Julia, there is precisely one function for adding polynomials over $\Z/n\Z$, and it can
be statically compiled for performance. The only time a decision has to be made about whether
to call this function, or another one called $+$, is at Jit compilation time. Every subsequent
time it is called (e.g. in a loop), no type decision code needs to be executed. Everything
is sorted out and compiled to efficient machine code before the loop even begins to iterate.

Needless to say, the performance benefits are great. It also greatly improves clarity
and readability of code, as specialised versions of generic functions are clearly
delineated by their type signatures.

One can still write generic, catch-all functions, which work over any ring, say. But
these do not first need to delegate to a whole bunch of special cases where specialised
algorithms can be used. The type system and compiler do all of this work automatically 
for you.

The only thing remaining for the generic function to do is to implement the generic
algorithm which works over arbitrary rings. The generic implementation only gets
called if no specialised implementation exists for those types.

Finally, with type unions, Julia types representing polynomials over various rings can
internally use multiple different data representations, even C objects. This means that
specialised implementations for particular rings can directly call native C functions,
with practically zero overhead.

\subsection{Problems with Julia}

Julia is by no means perfect, or optimal.

Below I outline some of the issues I've hit so far. Some can be solved and some intrinsically
belong to the design of Julia itself and likely won't be totally eliminated.

\subsubsection{1-indexed arrays}

All Julia arrays are indexed starting with $1$, i.e. \code{A[1]} is the first entry, not \code{A[0]}.

Most of the computer science community and a good proportion of the computational mathematical
community use $0$-indexed arrays.

This is nothing more than a nuisance to people who prefer the other convention. 

It can't be changed. One might be tempted to think that a preparser could simply add \code{+1} to
every array access. But there are other ways to access arrays than the \code{[]} notation.

It also doesn't need to be changed. The Julia language sprang up around people coming from a
specific mathematical background, and their tools use $1$-indexed arrays.

It should be considered a minor nuisance, nothing more. It is in fact easy to get used to,
and for example Pari/GP uses $1$-indexed arrays. So it is hardly unprecedented in the
computational and even number theoretic world. Some programmers struggle with off-by-one errors
for a few days.

\subsubsection{Garbage collection pauses}

Julia appears to suffer from ugly garbage collection pauses.

The following simple Julia program illustrates the issue

\begin{lstlisting}
a = big(1)

for i = 1:100000000
   if (i % 1000) == 0
      println(a)
   end
   
   a += 1
end
\end{lstlisting}

Every half a second or so, the output pauses for half a second, which is ugly and disconcerting.

The problem is that Julia is creating an object every iteration of the loop, and presumbably the
pauses are for the garbage collector to stop and clean up these objects.

In comparison, a language I have been writing, which also uses garbage collection and LLVM does
not have such pauses. 

Replacing the println statement in the above with \code{a += 1}, the Julia code takes 2 minutes.

Replacing the Julia bignum type with the Nemo ZZ type (described below), which uses flint bignums
instead of GMP bignums, drops the time to 82 seconds.

But my programming language (which also uses flint bignums) only takes 5.5 seconds.

Half of the problem here seems to be the garbage collection. The GC pauses seem to be about half
a second every second, which is clearly terrible.

But the garbage collector, no matter how much it is improved, is not going to fix this issue.

The problem is in fact that Julia allocates too many heap objects in the first place.

Most high level programming languages fall into one of two camps. Either they use heap allocated
objects and store pointers to them in variables and arrays, or they use stack allocated structs
and arrays of structs.

The advantage of the former is that assignment is very cheap. Simply make a copy of the pointer.
If you really want a copy of the data and not a copy of the reference to the object, you need
to explicitly call some kind of deep copy method.

However, the disadvantage is that if you modify one object, the other object will be modified too,
since they both point to the same data on the heap. To mitigate this, objects usually want to be
immutable so that you can have multiple references to the same object.

Every time an arithmetic operation is carried out, a new object is created to store the result
of the computation. You cannot simply modify the value of one of the existing objects. Thus,
operations like \code{+=} are unsafe, since they might alter the value of more than one variable.

Also, since an array will store pointers to objects, it will usually be populated with undefined
objects when the array is created (if not, you end up initialising objects twice, once when
creating the array and once again when filling it with values).

The other way to do things is to use structs on the stack to contain objects and arrays of structs.

This saves immediately on cache hits because all the data in an array is in one place, rather than
in a multitude of heap allocations. It also saves on object creation, as only one heap allocated
object is created, namely the array itself.

One disadvantage of this technique is that when assignment occurs, a deep copy of the data needs to
be made.

Another disadvantage of this technique is that you end up with a C++ style constructor/destructor
system, along with the complex semantics that go with it, including copy constructors, etc. When
a function returns, it may need to make a full copy of the object (it might have been allocated
on the stack), and when calling functions, copies may need to be made. That can be mitigated by
offering pass by reference, but then a mechanism needs to be provided to pass either by value or
reference.

Julia uses the first of the two models when you define your type using the keyword \code{type}. 
However, it reserves the right to use something like the second model if you use the keyword
\code{immutable}. Unfortunately, the result is an object that is really immutable. Not only can
you not have a finaliser for such a type, but you cannot even trick Julia into letting an external
library change the value (you can change the internals, but not the fields of the struct belonging 
to the type itself). 

Given these limitations of immutable types in Julia, one is currently obliged to use mutable types,
and as far as I can tell, this is the reason for the very slow performance in this microbenchmark.

Quite obviously, this problem is not going to go away without some effort, though the GC pauses 
themselves might be reduced as the GC itself improves. Fortunately, the Julia developers seem
extemely keen to work on improving bignum performance in Julia.

Neither method above provides an easy way to avoid creating a new object every time an arithmetic 
operation is performed (unless you use C-style \code{add(a, b, c)} semantics and eschew operator
overloading). It is possible to solve this problem with complex metaprogramming and delayed
evaluation, or with severely complex compiler magic which no one has ever mastered.

\subsubsection{Bignum parsing}

Languages that provide bignums have three choices.

Firstly, they can simply not provide access to a machine integer type. They might speed things up
as flint's fmpz does by smoothly transitioning from a machine integer to a bignum type upon
overflow. The disadvantage of this is loss of machine integer performance. This techique is still
around 6 times slower than native machine integer performance when Jit compiled.

Secondly, they can offer machine integers as the default type and ask the programmer to provide an
annotation when they intend to use a bignum. Julia 0.2 uses this system (it is apparently going to
change in 0.3).

The benefit is machine integer performance is the default. Also it is convenient when writing real
world programs, as array indices should be machine integers. Bignums tend to be used mainly by
number theorists, so it doesn't make sense for general purpose or even mathematical languages to
use any other convention.

The third option is to make bignums the default and ask the programmer to provide a notation if they
intend to use a machine integer. This has the advantage of no mathematical surprises. Performance can
suffer if the programmer forgets to provide the appropriate annotation where a machine integer should
be used. And things like array indices will usually require an annotation or some sort of (expensive)
automatic conversion.

The problem with Julia is that the only consistent way of specifying a bignum is with a string. The
cost of converting the string to a bignum isn't the problem. This can be avoided in most programs
since most constants are small and can be specified in other ways, e.g. by converting from a machine
integer.

But for large enough constants, the only way to do it is with a string. And the problem this causes
is that one cannot cut-and-paste the output of a program and use bignum values in subsequent input
without wrapping each bignum in a notation including string quotes.

This is incredibly tedious if you have a printed polynomial as output with large bignum coefficients.

If you didn't happen to save the output of a computation in a variable, there is no easy way to enter
it back in again with cut-n-paste. 

This is obviously a severe problem. 

It can conceivably be solved by allowing large constants to be parsed as bignums without annotations,
e.g. with a thin preparser.

The downside is that one cannot easily tell whether an integer literal will become a bignum or a
machine integer, without counting its digits or examining its type.

The only sensible solution for Nemo (not for Julia) is to make all constant integers bignums by default 
and require an annotation if a machine word is required. Of course this will be irritating when dealing 
with array indices and ranges.

In Julia 0.3 the problem has reportedly been compounded by making everything larger than two machine
words a bigint. This leads to an inconsistent semantics for integer literals.

It is possible to modify the Julia parser to deal with this issue, and someone has already indicated
how this can be done, by providing an example.

\subsubsection{Type parameters}

Currently when specifying a dependent type in Julia, one might write for example

\begin{lstlisting}
type mytype{R <: Ring}
   data :: R
   length :: Int
end
\end{lstlisting}

This creates a new type which depends on a type \code{R} which is a \code{Ring}, e.g. \code{R}  might
be the integers or a polynomial ring. The new type, called \code{mytype}, contains two fields: one is
of type \code{R} , the other a machine integer.

The useful thing about this syntax is that the type \code{R}  has a name, which we can use as a handle for
it, namely \code{R} and it is restricted to a type class (in this case \code{Ring}). We can use that name 
within the type definition itself, and also use it in any constructors we specify for the type. And when
the user tries to use the type, they can only instantiate it if \code{R} is a \code{Ring}.

But things are different if we want the type to depend on an integer value or a symbol.

\begin{lstlisting}
type mytype{R <: Ring, S}
   data :: R
   length :: Int
end
\end{lstlisting}

Now the type has two parameters. One is a type \code{R}, which is a \code{Ring}. The other, \code{S}, 
could be a \code{Symbol} for example. But there is currently no way to restrict it to be a 
\code{Symbol}). 

There is also a problem when we are defining methods whose signatures don't depend on that
\code{Symbol}. It seems that Julia won't even allow that type parameter to be mentioned in that case,
unless you are writing an inner constructor. That's a problem if you are trying to write a constructor
which takes a parameter of one parameterised type and trying to construct from it a value of another
parameterised type, e.g. you are trying to construct a value of the type given above from an array of
values whose types don't depend on \code{R} and \code{S}.

You can't use an outer constructor because the \code{R} and \code{S} can't be mentioned if they don't
appear in the types for the parameters you are passing. And you can't use an inner constructor because
currently Julia seems to ignore inner constructors that depend on additional parameters that the type 
you are constructing doesn't depend on.

To work around this, one literally has to use type introspection, and undocumented runtime type 
deconstruction from a more general inner constructor (if possible) and do different things depending
on the type parameters you find.

Two simple things would fix these problems.

Firstly, Julia should allow a type parameter \code{S} to be restricted to a \code{Symbol} or \code{Int}.

Secondly, either outer constructors should allow the type parameters for the type being constructed to 
be mentioned, even when they don't appear elsewhere in the prototype, or additional parameters should be 
allowed for inner constructors that aren't parameters for the type being constructed (and such inner 
constructors should not be ignored). It's not clear how the former would work, since there are two sets 
of type parameters here, the type parameters for the type being constructed, and the type parameters for
the arguments of the constructor. The two need to be separated somehow. The second solution might be
more practical. 

For all I know, this problem is already fixed in the latest unstable release of Julia (soon to be stable).
The Julia authors must surely have hit this themselves, unless there's something I don't understand
about the Julia type system.

\subsubsection{Supertypes of core types}

Julia has a type \code{Int} which represents a machine integer. This belongs to a hierachy of abstract
types, e.g. \code{Int <: Integer} and so on. 

Of course, we'd like to have \code{Int <: Ring} so that any code which depends on a type which is a subtype
of \code{Ring} can be instantiated with \code{Int}, e.g. we could define a polynomial ring over \code{Int}.

This is presumably possible, with rather a lot of rewriting of some Julia modules. But it certainly isn't
straightforward.

Again, as far as I can tell, Julia does the right thing here. But again, it is a real pain in the neck.

I don't see a simple workaround that I can be sure is efficient.

\subsubsection{A real nuisance}

The division functions in Julia are geared towards numerical, rather than algebraic, applications.

The main division operator \code{/} in Julia returns a floating point number when dividing integers
and the \code{div} function treats even the rationals as a model of the reals, so that \code{div(a, b)}
always returns the exact value $a/b$ (in the mathematical sense), truncated to the nearest whole
number in the direction of zero.

In particular, the \code{div} operator does not perform Euclidean division for rationals as it does
for the integers (the field of rationals is trivially a Euclidean domain). A similar observation holds
for \code{div} over the floating point numbers.

The upshot of this is that Julia needs an algebraic number stack to replace the current numeric one.

Fortunately, this is fairly easy to do in Julia, though it will take a substantial effort to implement. 

\subsubsection{A trivial complaint}

There is currently no easy way to change the Julia prompt to \code{nemo} instead of \code{julia}.

\section{A short introduction to the Julia language}

For a complete introduction to the Julia language, see the Julia website (\url{http://julialang.org/}).

Here we provide only a very basic overview of the simplest constructs in the Julia language which are
immediately relevant to Nemo.

For a cheat sheet, see \url{https://github.com/john9631/JuliaDocs/blob/master/JuliaReferenceCard.pdf?raw=true}.


\subsection{Code comments}

Code comments in Julia are written as follows

\begin{lstlisting}
# this is a commment
\end{lstlisting}

All characters from the hash to the end of the line are ignored.

\subsection{Values and core types}

Two core types of interest are the types for machine integers and double precision floats. We can
define values of these types as follows

\begin{lstlisting}
a = 123

b = 1.23

c = 1.23e-23
\end{lstlisting}

We can determine the type of a value or variable with the \code{typeof} operator. For example

\begin{lstlisting}
typeof(123)
\end{lstlisting}

returns either \code{Int32} or \code{Int64}, depending on your machine. You can refer to this type in
your code as an \code{Int}. This will refer to either \code{Int32} or \code{Int64} depending on your
machine.

Similarly

\begin{lstlisting}
typeof(1.23)
\end{lstlisting}

returns \code{Float64}.

Another important way of creating values of a given type is with a constructor. For the above core
types, the constructor has the same name as the type, but with lowercase first letter, e.g.

\begin{lstlisting}
a = int(123)
\end{lstlisting}

Julia has a built-in bignum type. But we will not use it in Nemo. Instead, we have provided a type
\code{ZZ} which uses flint bignums. One slight quirk of Julia is that the constructor for \code{ZZ}
has the same name as the type without the lowercase first letter, e.g. we write for example

\begin{lstlisting}
a = ZZ(123)
\end{lstlisting}

Some other types of interest are \code{String} and \code{Int8}.

\begin{lstlisting}
a = int8(123)

s = "Nemo is awesome"
\end{lstlisting}

\subsection{Julia operators}

For its numeric values, Julia provides the following arithmetic operators where applicable

\code{+, -, *, /, %, //, div, rem, +=, -=, *=, /=, %=, //=, ^, ^=}

Most of these are self explanatory. Unfortunately the single forward slash returns a floating point
value when passed two integer operands. The double forward slash results in a rational value. This
is opposite to the convention algebraists would wish for, and illustrates the numeric bent of Julia's
designers. 

We advise not ever using the \code{/} operator in Nemo, but always using \code{div}. This will not
result in mathematical theorems being false. See the section above complaining about this. 

The \code{div} operator provides integer division. Unfortunately it uses the C convention of rounding
towards zero, instead of the floor division one would hope for as an algebraist. This is tolerable of
course, just a slight nuisance.

The caret operator \code{^} is for powering, not xor as in C. This is great for mathematicians, 
especially when creating polynomials.

Julia provides the following comparison operators

\code{==, <, >, <=, >=, !=}

All of the comparison operators return a \code{Bool}, and unlike C an integer cannot stand in for
a \code{Bool} in a conditional expression. A \code{Bool} has either the value \code{true} or
\code{false}.

There are the following logical operators in Julia

\code{|, &, $, |=, &=, $=, !}

The only one which may be unfamiliar is the xor operator \code{$}.

\subsection{Control flow}

The following standard control flow statements are available in Julia

\begin{lstlisting}
if a < 10
   # do something
elseif a < 100
   # do something else
else
   # do something totally different
end
\end{lstlisting}

We note that \code{if} statements are also expressions if the final line of each block is an expression.
This allows a more functional style of programming.

\begin{lstlisting}
while i < 10
   println(i)
end
\end{lstlisting}

I'm not aware of any \code{do...while} like construct in Julia. This is an unfortunate omission.

One can use the keyword \code{break} to break from a loop.

\begin{lstlisting}
for i = 1:5
   println(i)
end
\end{lstlisting}

Here \code{1:5} is a range, which includes the endpoints.

\begin{lstlisting}
for s in ["foo","bar","baz"]
   println(s)
end
\end{lstlisting}

This last form can be used with any iterable container. The particular container in the example is
of course a 3-element array.

\subsection{Arrays}

\code{Array} in Julia is a parameterised type. You can have an array of any other type, and the 
number of dimensions of the array is an \code{Int} parameter of the type.

For example, the type of a 2-dimensional array of \code{Int}'s in Julia is \code|Array{Int, 2}|.

To create an array of undefined entries, use the \code{Array} constructor.

\begin{lstlisting}
a = Array(Int, 5, 3)
\end{lstlisting}

In this example, we create an array of \code{Int}'s with two dimensions, the first is length $5$,
the second of length $3$. So the type of \code{a} is precisely \code|Array{Int, 2}|.

We can access elements of an array with the usual array syntax

\begin{lstlisting}
a[1,2] = 4
\end{lstlisting}

A second way to construct an array is with an array literal

\begin{lstlisting}
a = [1, 2, 3, 2, 3, 4, 7, 9, 3, 2, 4, 2]
reshape(a, 4, 3)
\end{lstlisting}

One can also use ranges

\begin{lstlisting}
a = reshape(1:9, 3, 3)
\end{lstlisting}

and comprehensions

\begin{lstlisting}
a = [i^2 for i = 1:10]
\end{lstlisting}

\subsection{Functions}

One does not need to provide type declarations when defining a function in Julia. The dynamic
type inference can often work out the types and no performance is lost.

\begin{lstlisting}
function factorial(n)
   if n == 1
      return 1
   end

   r = 1
   
   for i = 2:n
     r *= i
   end

   return r  
end
\end{lstlisting}

The \code{return} keyword on the final line of the function is optional. If the final line is 
an expression, the value of that expression will be returned.

One can also use a more mathematical notation to define functions

\begin{lstlisting}
f(x) = x^2 + 2x + 1
\end{lstlisting}

Note that I have optionally omitted the \code{*} operator between the \code{2} and \code{x}.

In either case, application of the function is exactly as expected

\begin{lstlisting}
f(10)
\end{lstlisting}

If one does wish to supply types, e.g. when writing specialised versions of a function, one
can do so.

\begin{lstlisting}
function factorial(n::Int)
   if n == 1
      return 1
   end

   r = 1
   
   for i = 2:n
     r *= i
   end

   return r  
end
\end{lstlisting}

\subsection{Generic functions}

Sometimes one would like to restrict the types of values that a function will apply to. For
example, one might like to write a function which works for any kind of \code{Integer}, e.g.
\code{Int8}, \code{Int16}, \code{Int32}, \code{Int64}, etc.

We can do this by  restricting types to belong to some abstract superclass.

\begin{lstlisting}
function factorial{R <: Integer}(n::R)
   if n == 1
      return 1
   end

   r = 1
   
   for i = 2:n
     r *= i
   end

   return r  
end
\end{lstlisting}

Now our factorial function will work, so long as it is passed a value whose type \code{R} is
an \code{Integer} type. The \code{Integer} abstract type does not have any specific
representation in Julia, it is just an abstract node in the type graph to which all the
integer-like types are attached.

In Nemo we define an abstract type called \code{Ring}, to which all types that are rings
are attached. This means we can write generic functions which accept arguments so long as
their type belongs to the abstract type \code{Ring}. For example, the Nemo bignum type
\code{ZZ} belongs to the abstract type \code{Ring} as does the \code{Poly} type.

\subsection{User defined types}

You can define your own \code{Ring} types as follows

\begin{lstlisting}
type mytype{R <: Ring} <: Ring
   a :: R
   b :: Int
   c :: Float64
end
\end{lstlisting}

This defines a new parameterised type called \code{mytype}. It depends on another type
\code{R} which belongs to \code{Ring}. The new type is then also declared to belong to
\code{Ring}.

The type contains three fields: a field \code{a} of type \code{R}, a field \code{b} of
type \code{Int} and a field \code{c} of type \code{Float64}.

Note that this really defines a whole family of types, one for each type \code{R}.

Julia automatically creates a constructor for this type (unless you override it). For
example, since the Nemo type \code{ZZ} is a \code{Ring}, we can create a value of
type \code|mytype{ZZ}| as follows

\begin{lstlisting}
s = mytype(ZZ(10), 12, 1.23)
\end{lstlisting}

Here, Julia has provided the \code{mytype} constructor for free. Simply pass it three
values, corresponding to the values that should go into the three fields of the 
\code{mytype}, and it will work out the rest (including that \code{R} should be
\code{ZZ} in this case).

To access the fields of \code{s} is also easy

\begin{lstlisting}
println(s.c)
\end{lstlisting}

will print the value \code{1.23}, since the \code{c} field of \code{s} contains the
value \code{1.23} after we created it using the constructor.

\subsection{Tuples}

Julia can trivially create tuples

\begin{lstlisting}
t = (123, ZZ(12))
\end{lstlisting}

This creates a value of type \code{(Int, ZZ)}.

Importantly, tuples can be returned from and passed as arguments to functions.

Julia also has a neat tuple assignment, which is very useful

\begin{lstlisting}
a, b = 1, 2
\end{lstlisting}

Note the omission of the optional parentheses in this example.

Moreover, this can be used to write a very neat swap

\begin{lstlisting}
a, b = b, a
\end{lstlisting}

To specify a tuple with only one component, one must append a comma

\begin{lstlisting}
s = (1,)
\end{lstlisting}

This is now a tuple of length 1.

Note that tuples may contain inhomogeneous types. 

Arrays can too, in which case the types will be made the generic type \code{Any} (or
at least some abstract type to which all the types belong). 
But performance will suffer in the case of arrays, as with any code where Julia infers
type \code{Any}.

\subsection{Print and println}

The \code{print} function can take a comma separated list of values, which it will
then print to the console. The \code{println} function will do the same, but append
a newline character.

\begin{lstlisting}
a = 12

println("a = ", a)
\end{lstlisting}

\subsection{Timing and profiling}

To time how long a statement takes to execute, one can use the \code{@time} macro.

\begin{lstlisting}
function sumit(n::Int)
   s = 0

   for i = 1:n
      s += i
   end

   return s
end

@time sumit(1000000000)
\end{lstlisting}

The result of this call on my computer is

\begin{verbatim}
julia> @time sumit(1000000000)
elapsed time: 0.914578447 seconds (78060 bytes allocated)
500000000500000000
\end{verbatim}

We can get a breakdown of where Julia spends all its time, function by function,
using the profile macro.

\begin{lstlisting}
@profile sumit(1000000000)

Profile.print()
\end{lstlisting}

This causes Julia to take a number of backtrace samples and count the number of times
each function is called. It also tells you which files and line numbers the various
functions are defined on.

\begin{verbatim}
julia> Profile.print()
       912 client.jl; _start; line: 429
        912 client.jl; run_repl; line: 186
           912 client.jl; eval_user_input; line: 109
              912 profile.jl; anonymous; line: 14
               912 none; sumit; line: 5
\end{verbatim}

\section{Installing Nemo}

There are currently three steps to installing Nemo: install flint, install Julia and
clone the Nemo git repository.

Installing flint is described in detail in the flint documentation. Nemo currently
depends on features of flint only available in the bleeding edge git repository,
which can be obtained as follows

\begin{verbatim}
git clone https://github.com/wbhart/flint2
\end{verbatim}

The other instructions are as per the manual for flint-2.4 on the flint website (see
\url{http://flintlib.org}). Note that flint-2.4 requires GMP 5 or MPIR 2.7 and MPFR
3.1.

To install Julia, please refer to the installation instructions on the Julia website
(\url{http://julialang.org/}).

On Ubuntu, if you have root access, you can simply add a ppa and use apt-get. E.g. on
my system it was as follows

\begin{verbatim}
sudo add-apt-repository ppa:staticfloat/juliareleases
sudo apt-get update
sudo apt-get install julia
\end{verbatim}

Then you need to download the Nemo git repository

\begin{verbatim}
git clone https://github.com/wbhart/nemo
\end{verbatim}

Finally, edit the nemo script by setting the library directories for GMP/MPIR, MPFR
and flint appropriately.

To run nemo, just type

\begin{verbatim}
./nemo
\end{verbatim}

The Julia prompt will appear. If everything went according to plan, you can now use 
Julia, including all of the Nemo functionality described in the chapters below.

\section{The Rings module}

Julia has a module system, and we use it to provide access to Nemo modules.

At present there is a single module, called \code{Rings}. To import it and use all
exported functionality simply type

\begin{lstlisting}
using Rings
\end{lstlisting}

The first thing the \code{Rings} module does is define a new abstract type called
\code{Ring}. Internally, this is the line of code that does this

\begin{lstlisting}
abstract Ring
\end{lstlisting}

This provides a new node in the type graph to which we can attach other types. 

You can check (or assert) that a given type belongs to \code{Ring} with the
\code{<:} operator. For example, we can check that the Nemo type \code{ZZ} belongs
to \code{Ring}

\begin{lstlisting}
ZZ <: Ring
\end{lstlisting}

Nemo will return \code{true}, indicating that \code{ZZ} does belong to \code{Ring}.

For convenience, I will refer to \code{Ring} as a class. So we will say that the 
type \code{ZZ} belongs to the type class \code{Ring}, or that \code{ZZ} belongs to
the \code{Ring} class.

Beware that in Julia, abstract types can belong to other abstract types. E.g. we
can have

\begin{lstlisting}
QQ <: Field <: Ring
\end{lstlisting}

This is clearly rather convenient.

Another thing to be aware of is that Julia's parametric type system is invariant,
not covariant. This means that even if \code{R <: S} we don't automatically have
\code|Ring{R} <: Ring{S}|.

The reason for this is that the underlying representation of \code|Ring{R}| may
differ from that of \code|Ring{S}|. Therefore it makes no sense type theoretically
for one to be a subtype of the other.

Types model categories, but are not formally equivalent to them! In fact, type
systems are equivalent to formal logic systems (look up the Curry-Howard
correspondence and the lambda cube for more details).

\subsection{Bignum integers}

Nemo provides a bignum type \code{ZZ}.

Internally, \code{ZZ} uses the flint \code{fmpz} type. In fact, here is the Nemo
definition of the \code{ZZ} type

\begin{lstlisting}
type ZZ <: Ring
    d::Int
end
\end{lstlisting}

Since an \code{fmpz} in flint is just implemented as a 32 or 64 integer, this now 
provides the same type in Nemo. We can directly call flint functions on objects of
type \code{ZZ} (fortunately an \code{fmpz_t} is a pointer to an \code{fmpz} in 
flint, so that Julia's habit of defining objects as heap allocated objects will 
precisely result in an \code{fmpz_t}).

\subsubsection{Constructors}

To create a bignum value, Nemo provides various constructors. Space is automatically
recovered when the created object goes out of scope.

\begin{lstlisting}
ZZ()
\end{lstlisting}

\desc{Creates an initialised \code{ZZ}. This function is only useful internally, 
inside functions that can modify the value in an unsafe way, since the value of the
created bignum is zero.}

\begin{lstlisting}
ZZ(n::Int)
\end{lstlisting}

\desc{Create a bignum with the given signed value $n$.}

\begin{lstlisting}
ZZ(n::Uint)
\end{lstlisting}

\desc{Create a bignum with the given unsigned value $n$.}

\begin{lstlisting}
ZZ(n::Bool)
\end{lstlisting}

\desc{Create a bignum which is $1$ if $n$ is \code{true} or $0$ if $n$ is 
\code{false}.}

\begin{lstlisting}
ZZ(s::String)
\end{lstlisting}

\desc{Create a bignum whose value is represented (in decimal) by the given string
$s$. The string should not contain any whitespace, and can optionally begin with
a $-$ sign.}

\begin{lstlisting}
ZZ(x::Float64)
\end{lstlisting}

\desc{If $x$ represents an exact integer, create a bignum with that value. Otherwise
an \code{InexactError()} exception is thrown.}

\begin{lstlisting}
ZZ(x::ZZ)
\end{lstlisting}

\desc{Returns a reference to $x$. No copy of the data is made.}

\begin{lstlisting}
deepcopy(x::ZZ)
\end{lstlisting}

\desc{Create a new bignum whose value is arithmetically equal to that of $x$.}

\textbf{Examples.}

Here are some examples of the above constructors.

\begin{lstlisting}
a = ZZ(-123)
b = ZZ(12.0)
c = ZZ("-1234567876545678376545678900000000000000000000000000")
d = ZZ(c)
e = deepcopy(c)
\end{lstlisting}

\subsubsection{Basic manipulation}

Various functions are provided to do basic manipulations in \code{ZZ}.

\begin{lstlisting}
one(::Type{ZZ})
\end{lstlisting}

\desc{Create the multiplicative identity element in the ring of integers.}

\begin{lstlisting}
zero(::Type{ZZ})
\end{lstlisting}

\desc{Create the additive identity element in the ring of integers.}

\begin{lstlisting}
sign(a::ZZ)
\end{lstlisting}

\desc{Return either $-1$, $0$ or $1$ depending on whether the sign of $a$ is negative,
zero or positive, respectively. The returned value is of type \code{Int}.}

\begin{lstlisting}
fits(::Type{Int}, a::ZZ)
fits(::Type{Uint}, a::ZZ)
\end{lstlisting}

\desc{Return \code{true} if the value $a$ will fit into a variable of the given
type. Otherwise return \code{false}.}

\begin{lstlisting}
size(a::ZZ)
\end{lstlisting}

\desc{Return the number of machine words that make up the bignum $a$. The
returned value has type \code{Int}.}

\begin{lstlisting}
canonical_unit(a::ZZ)
\end{lstlisting}

\desc{This is used for canonicalising fractions. The function simply returns $-1$
if $a < 0$, otherwise it returns $1$.}

\textbf{Examples.}

Here are some examples of the above basic manipulations.

\begin{lstlisting}
a = one(ZZ)
b = zero(ZZ)

if sign(a) < 0
   println("Negative")
end

if fits(Int, a)
   println("Fits into an Int")
end

s = size(a)

t = canonical_unit(ZZ(-12))
\end{lstlisting}

\subsubsection{Binary operators and functions}

The following standard binary operators are provided for \code{ZZ}.

\begin{lstlisting}
+(a::ZZ, b::ZZ)
-(a::ZZ, b::ZZ)
*(a::ZZ, b::ZZ)
%(a::ZZ, b::ZZ)
&(a::ZZ, b::ZZ)
|(a::ZZ, b::ZZ)
$(a::ZZ, b::ZZ)
\end{lstlisting}

Note that \code{%} follows the C (and Julia) convention of rounding the quotient
towards zero. If $b = 0$ is passed to \code{%}, a \code{DivideError()} is thrown.

Julia automatically provides all of the combined assignment operators \code{+=, *=, &=}
etc.

Various kinds of integer division are provided.

\begin{lstlisting}
fdiv(a::ZZ, b::ZZ)
cdiv(a::ZZ, b::ZZ)
tdiv(a::ZZ, b::ZZ)
div(a::ZZ, b::ZZ)
\end{lstlisting}

\desc{Integer division with rounding towards $-\infty$, $+\infty$ and $0$ respectively.
Note \code{div} is a synonym for \code{tdiv}. If $b = 0$ is passed to any of these
functions, a \code{DivideError()} is thrown.}

\begin{lstlisting}
mod(a::ZZ, b::ZZ)
rem(a::ZZ, b::ZZ)
%(a::ZZ, b::ZZ)
\end{lstlisting}

\desc{Integer remainder after division with rounding towards $-\infty$ and $0$
respectively. Note that \code{\%} is a synonym for \code{rem}. If $b = 0$ is passed to 
any of these functions, a \code{DivideError()} is thrown.}

\begin{lstlisting}
divexact(a::ZZ, b::ZZ)
\end{lstlisting}

\desc{Exact integer division. This is more efficient than the above division functions,
but will only return a meaningful result if the division is exact, i.e. if $b$ divides
$a$. If $b = 0$ is passed to this function, a \code{DivideError()} is thrown.}

\begin{lstlisting}
gcd(a::ZZ, b::ZZ)
\end{lstlisting}

\desc{Returns the greatest common divisor of $a$ and $b$. For convenience, 
gcd$(a, 0) = a$ and gcd$(0, b) = b$. The returned value is always nonnegative.}

\begin{lstlisting}
lcm(a::ZZ, b::ZZ)
\end{lstlisting}

\desc{Returns the lowest common multiple of $a$ and $b$, i.e. $ab/\gcd(a, b)$ if
$a, b > 0$. For convenience, lcm$(a, 0) = 0$ and lcm$(0, b) = 0$. The returned
value is always nonnegative.}

\begin{lstlisting}
flog(a::ZZ, b::ZZ)
\end{lstlisting}

\desc{Returns $\log_b(a)$ rounded towards $0$. Both $a$ and $b$ are required
to be positive, otherwise a \code{DomainError()} exception is thrown.}

\begin{lstlisting}
clog(a::ZZ, b::ZZ)
\end{lstlisting}

\desc{Returns $\log_b(a)$ rounded towards $\infty$. Both $a$ and $b$ are required
to be positive, otherwise a \code{DomainError()} exception is thrown.}

\textbf{Examples.}

Here are some examples of the binary operators and functions.

\begin{lstlisting}
a = ZZ(12)
b = ZZ(26)

c = a + b
d = a - b
e = gcd(a, b)
f = lcm(a, b)
\end{lstlisting}

\subsubsection{Ad hoc operators and functions}

Since the Julia types \code{Int} and \code{Uint} cannot be made members of the
\code{Ring} class, we must define some ad hoc operators, so that values of type
\code{ZZ} can be more easily combined with \code{Int} and \code{Uint} values.

\begin{lstlisting}
+(x::ZZ, c::Uint)
+(x::ZZ, c::Int)
+(x::Uint, c::ZZ)
+(x::Int, c::ZZ)
-(x::ZZ, c::Uint)
-(x::ZZ, c::Int)
-(x::Uint c::ZZ)
-(x::Int, c::ZZ)
*(x::ZZ, c::Uint)
*(x::ZZ, c::Int)
*(x::Uint, c::ZZ)
*(x::Int, c::ZZ)
\end{lstlisting}

We also define the following, which have the same semantics as the corresponding
binary operators and functions above.

\begin{lstlisting}
tdiv(x::ZZ, c::Int)
fdiv(x::ZZ, c::Int)
cdiv(x::ZZ, c::Int)
div(x::ZZ, c::Int)
rem(x::ZZ, c::Int)
mod(x::ZZ, c::Int)
%(x::ZZ, c::Int)
divexact(x::ZZ, c::Int)
flog(x::ZZ, c::Int)
clog(x::ZZ, c::Int)
\end{lstlisting}

There are also shift operators, which require the shift to be of type \code{Int}.

\begin{lstlisting}
<<(x::ZZ, c::Int)
\end{lstlisting}

\desc{Return $2^c x$.}

\begin{lstlisting}
fdivpow2(x::ZZ, c::Int)
cdivpow2(x::ZZ, c::Int)
tdivpow2(x::ZZ, c::Int)
>>(x::ZZ, c::Int)
\end{lstlisting}

\desc{Return $x/2^c$ with rounding towards $-\infty$, $+\infty$ and $0$ respectively. 
Note that \code{>>} is a synonym for \code{fdivpow2}.}

There is also the caret operator, which is used for powering in Julia (and Nemo), in
line with the mathematical convention.

\begin{lstlisting}
^(x::ZZ, a::Uint)
^(x::ZZ, a::Int)
\end{lstlisting}

\desc{Return $x^a$. Requires $a \geq 0$.}

\textbf{Examples.}

Here are some examples of the ad hoc operators and functions.

\begin{lstlisting}
a = ZZ(-12)

b = 3 + a
c = a + 3
d = a - 3
e = 5 - a
f = rem(a, 7)
g = a >> 3
h = fdivpow2(a,2)
j = a^10
\end{lstlisting}

\subsubsection{Comparison operators and functions}

The following standard comparison operators are provided for \code{ZZ}.

\begin{lstlisting}
==(a::ZZ, b::ZZ)
>(a::ZZ, b::ZZ)
<(a::ZZ, b::ZZ)
<=(a::ZZ, b::ZZ)
>=(a::ZZ, b::ZZ)
\end{lstlisting}

Julia automatically provides a \code{!=} operator.

Note that all these comparisons yield a result of type \code{Bool}.

There are also the following functions.

\begin{lstlisting}
cmp(x::ZZ, y::ZZ)
\end{lstlisting}

\desc{Return a negative integer if $x < y$, a positive integer if $x > y$ and zero if $x = y$.}

\begin{lstlisting}
cmpabs(x::ZZ, y::ZZ)
\end{lstlisting}

\desc{Return a negative integer if $|x| < |y|$, a positive integer if $|x| > |y|$ and zero if 
$|x| = |y|$, where $|x|$ is the absolute value of $x$.}

\textbf{Examples.}

Here are some examples of the comparison operators and functions.

\begin{lstlisting}
a = ZZ(-12)
b = ZZ(5)

if a < b
   println("a < b")
end

if cmpabs(a, b) == 0
   println("The absolute values of a and b are equal")
end
\end{lstlisting}

\subsubsection{Ad hoc comparison operators}

We overload the comparison operators to more easily deal with values of type \code{Int}.

\begin{lstlisting}
==(a::ZZ, b::Int)
==(a::Int, b::ZZ)
>(a::ZZ, b::Int)
>(a::Int, b::ZZ)
<(a::ZZ, b::Int)
<(a::Int, b::ZZ)
<=(a::ZZ, b::Int)
<=(a::Int, b::ZZ)
>=(a::ZZ, b::Int)
>=(a::Int, b::ZZ)
\end{lstlisting}

\textbf{Examples.}

Here are some examples of the ad hoc comparison operators.

\begin{lstlisting}
a = ZZ(-12)

if a < 7
   println("a < 7")
end

if a == -12
   println("a == -12")
end
\end{lstlisting}

\subsubsection{Unary operators and functions}

\begin{lstlisting}
-(x::ZZ)
\end{lstlisting}

\desc{Return $-x$.}

\begin{lstlisting}
~(x::ZZ)
\end{lstlisting}

\desc{Return the bignum corresponding to logical complement of the twos 
complement representation of x, namely $-x - 1$.}

\begin{lstlisting}
abs(x::ZZ)
\end{lstlisting}

\desc{Return the absolute value of $x$, i.e. $x$ if $x >= 0$ and $-x$ otherwise.}

\textbf{Examples.}

Here are some examples of the unary operators and functions.

\begin{lstlisting}
a = -ZZ(12)
b = ~ZZ(-5)
c = abs(a)
\end{lstlisting}

\subsubsection{Division with remainder}

\begin{lstlisting}
fdivrem(a::ZZ, b::ZZ)
tdivrem(a::ZZ, b::ZZ)
divrem(a::ZZ, b::ZZ)
\end{lstlisting}

\desc{Return a tuple $(q, r)$ consisting of the quotient and remainder after 
division of $x$ by $y$, with rounding towards $-\infty$ and $0$ respectively. Note 
that \code{divrem} is a synonym for \code{tdivrem}. If $b = 0$ is passed to any
of these functions a \code{DivideError()} is thrown.}

\textbf{Examples.}

Here are some examples of the unary operators and functions.

\begin{lstlisting}
q, r = fdivrem(ZZ(12), ZZ(5))
q, r = tdivrem(ZZ(12), ZZ(5))
\end{lstlisting}

\subsubsection{Roots}

\begin{lstlisting}
isqrt(x::ZZ)
\end{lstlisting}

\desc{Return the square root of $x$, rounded down to the nearest integer. If $x < 0$
a \code{DomainError()} is thrown.}

\begin{lstlisting}
isqrtrem(x::ZZ)
\end{lstlisting}

\desc{Return a tuple $(s, r)$ consisting of the square root of $x$, rounded down to the 
nearest integer and the remainder, i.e. $r = x - s^2$. If $x < 0$ a \code{DomainError()}
is thrown.}

\begin{lstlisting}
root(x::ZZ, n::Int)
\end{lstlisting}

\desc{Return the $n$-th root of $x$, rounded down to the nearest integer. If $x < 0$ and
$n$ is even, a \code{DomainError()} is thrown. If $n \leq 0$ a \code{DomainError()} is
thrown.}

\textbf{Examples.}

Here are some examples of the root taking functions.

\begin{lstlisting}
s = isqrt(ZZ(12))
s, r = isqrtrem(ZZ(12))
r = root(ZZ(1000), 3)
\end{lstlisting}

\subsubsection{Extended GCD}

\begin{lstlisting}
xgcd(a::ZZ, b::ZZ)
\end{lstlisting}

\desc{Return a tuple $(g, s, t)$ consisting of the greatest common divisor of $a$ and $b$
and values $s$ and $t$ such that $g = as + bt$, with $-b \leq s \leq b$ and 
$-a \leq t \leq a$.}

\begin{lstlisting}
gcdinv(a::ZZ, b::ZZ)
\end{lstlisting}

\desc{Return a tuple $(g, s)$ consisting of the greatest common divisor of $a$ and $b$
and a value $0 \leq s < b$ such that there exists a value $t$ such that 
$g = as + bt$. If $a < 0$ or $b < a$, a \code{DomainError()} is thrown.}

\textbf{Examples.}

Here are some examples of the extended GCD functions.

\begin{lstlisting}
g, s, t = xgcd(ZZ(12), ZZ(5))
g, s = gcdinv(ZZ(5), ZZ(12))
\end{lstlisting}

\subsubsection{Bit twiddling}

Various functions are provided to deal with bignums on a binary bit level.

\begin{lstlisting}
popcount(x::ZZ)
\end{lstlisting}

\desc{Return the number of binary ones in the binary representation of $x$. If $x < 0$ the
function will return $0$. The result that is returned is of type \code{Int}.}

\begin{lstlisting}
prevpow2(x::ZZ)
\end{lstlisting}

\desc{Return the largest power of $2$ which does not exceed $x$. If $x < 0$ the result is
set to \code{-prevpow2(-x)}.}

\begin{lstlisting}
nextpow2(x::ZZ)
\end{lstlisting}

\desc{Return the smallest power of $2$ which is not less than $x$. If $x < 0$ the result is
set to \code{-nextpow2(-x)}.}

\begin{lstlisting}
trailing_zeros(x::ZZ)
\end{lstlisting}

\desc{Return the number of trailing zeros in the binary representation of the absolute
value of $x$.}

\begin{lstlisting}
clrbit!(x::ZZ, n::Int)
\end{lstlisting}

\desc{Set bit $n$ in the binary representation of the absolute value of $x$ to $0$. Bits
are numbered starting with $n = 0$ for the least significant bit. N.B. this function does
not return the result, but alters the value of $x$. This is an unsafe operation which will
change the value of all variables which contain a reference to $x$.}

\begin{lstlisting}
setbit!(x::ZZ, n::Int)
\end{lstlisting}

\desc{Set bit $n$ in the binary representation of the absolute value of $x$ to $1$. Bits
are numbered starting with $n = 0$ for the least significant bit. N.B. this function does
not return the result, but alters the value of $x$. This is an unsafe operation which will
change the value of all variables which contain a reference to $x$.}

\begin{lstlisting}
combit!(x::ZZ, n::Int)
\end{lstlisting}

\desc{Complement bit $n$ in the binary representation of the absolute value of $x$. Bits
are numbered starting with $n = 0$ for the least significant bit. N.B. this function does
not return the result, but alters the value of $x$. This is an unsafe operation which will
change the value of all variables which contain a reference to $x$.}

\textbf{Examples.}

Here are some examples of the bit twiddling functions.

\begin{lstlisting}
a = ZZ(12)

p = popcount(a)
b = nextpow2(a)
combit!(a, 2)
\end{lstlisting}

\subsubsection{Alternative bases}

\begin{lstlisting}
base(n::ZZ, b::Int)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in the given base $b$. Valid
bases are $2 \leq b \leq 62$. If an invalid base is applied an error is raised.}

\begin{lstlisting}
bin(n::ZZ)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in binary, i.e. base $2$.}

\begin{lstlisting}
oct(n::ZZ)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in octal, i.e. base $8$.}

\begin{lstlisting}
dec(n::ZZ)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in decimal, i.e. base $10$.}

\begin{lstlisting}
hex(n::ZZ)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in hexadecimal, i.e. base $16$.}

\begin{lstlisting}
ndigits(n::ZZ, b::Integer = 10)
\end{lstlisting}

\desc{Return an \code{Int} representing the number of digits required to represent the
absolute value of $n$ as a string in base $b$. The default is $b = 10$. Note that $0$
always requires one digit as a string.}

\begin{lstlisting}
nbits(n::ZZ)
\end{lstlisting}

\desc{Return an \code{Int} representing the number of bits required to represent the
absolute value of $n$ in binary. We take the convention that $0$ requires $0$ binary 
bits.}

\textbf{Examples.}

Here are some examples of the functions for alternative bases.

\begin{lstlisting}
a = ZZ(12)

s1 = bin(a)
s2 = base(a, 13)
n1 = nbits(a)
n2 = ndigits(a, 3)
\end{lstlisting}

\subsubsection{String I/O}

\begin{lstlisting}
string(x::ZZ)
\end{lstlisting}

\desc{Return a unicode string representation of the value of $x$ in decimal, including the sign
if $x < 0$.}

\textbf{Examples.}

Here is an example of string I/O.

\begin{lstlisting}
a = ZZ(12)
s = string(a)
println(s[1])
\end{lstlisting}

\subsubsection{Modular arithmetic}

\begin{lstlisting}
powmod(x::ZZ, p::ZZ, m::ZZ)
\end{lstlisting}

\desc{Return $x^p \pmod{m}$. If $m \leq 0$ a \code{DomainError()} is thrown.}

\begin{lstlisting}
powmod(x::ZZ, p::Int, m::ZZ)
\end{lstlisting}

\desc{Return $x^p \pmod{m}$. If $m \leq 0$ a \code{DomainError()} is thrown.}

\begin{lstlisting}
invmod(x::ZZ, m::ZZ)
\end{lstlisting}

\desc{Return $x^{-1} \pmod{m}$. If $m \leq 0$ a \code{DomainError()} is thrown. If
an impossible inverse is encountered, an exception is thrown.}

\begin{lstlisting}
gcdinv(x::ZZ, m::ZZ)
\end{lstlisting}

\desc{Returns the pair \code{g, xinv} where $g$ is the greatest common divisor of
$x$ and $m$ and \code{xinv} is $x^{-1} \pmod{m}$. If $m \leq 0$ a 
\code{DomainError()} is thrown.}

\begin{lstlisting}
sqrtmod(x::ZZ, m::ZZ)
\end{lstlisting}

\desc{Return the square root of $x$ modulo $m$. If $m \leq 0$ a \code{DomainError()}
is thrown. If $x$ is not a square modulo $m$, an exception is thrown. Requires $m$ to
be prime. This condition is not checked and an infinite loop may result if $m$ is
not prime.}

\begin{lstlisting}
crt(r1::ZZ, m1::ZZ, r2::ZZ, m2::ZZ, sign::Bool)
crt(r1::ZZ, m1::ZZ, r2::Int, m2::Int, sign::Bool)
\end{lstlisting}

\desc{Return a value $r$ such that $r \equiv r1 \pmod {m1}$ and $r \equiv r2 \pmod{m2}$.
If \code{sign = true} the value will be in the range \code{-m1*m2/2 < r <= m1*m2/2}. If
\code{sign = false} the value will be in the range \code{0 <= r < m1*m2}.}

\textbf{Examples.}

Here are some examples of modular arithmetic.

\begin{lstlisting}
a = powmod(ZZ(12), ZZ(110), ZZ(13))
a = powmod(ZZ(12), 110, ZZ(13))
b = invmod(ZZ(12), ZZ(13))
c = sqrtmod(ZZ(12), ZZ(13))
d = crt(ZZ(5), ZZ(13), ZZ(7), ZZ(37), true)
\end{lstlisting}

\subsubsection{Number theoretic/combinatorial functions}

\begin{lstlisting}
divisible(x::ZZ, y::ZZ)
divisible(x::ZZ, y::Int)
\end{lstlisting}

\desc{Return \code{true} if $x$ is divisible by $y$, otherwise return \code{false}. If
$y = 0$ a \code{DivideError()} is raised.}

\begin{lstlisting}
issquare(x::ZZ)
\end{lstlisting}

\desc{Return \code{true} if $x$ is a perfect square, otherwise return \code{false}.}

\begin{lstlisting}
isprime(x::ZZ)
\end{lstlisting}

\desc{Return \code{true} if $x$ is prime, otherwise return \code{false}.}

\begin{lstlisting}
isprobabprime(x::ZZ)
\end{lstlisting}

\desc{Return \code{true} if $x$ is very probably prime, otherwise return \code{false}.}

\begin{lstlisting}
remove(x::ZZ, y::ZZ)
\end{lstlisting}

\desc{Returns a pair $(n, z)$ where $n$ is an \code{Int} and $z$ a \code{ZZ} such that
$x = y^nz$ and $z$ is not divisible by $y$. If $y = 0$ a \code{DivideError()} is thrown.}

\begin{lstlisting}
divisor_lenstra(n::ZZ, r::ZZ, m::ZZ)
\end{lstlisting}

\desc{If $n$ has a factor which lies in the residue class $r \pmod{m}$ for $0 < r < m < n$,
this function returns such a factor. Otherwise it returns $0$. This is only efficient if 
$m$ is at least the cube root of $n$. We require gcd$(r, m) = 1$ and this condition is not
checked.}

\begin{lstlisting}
fac(n::Int)
\end{lstlisting}

\desc{Return as a \code{ZZ} the factorial of $n$, i.e. $n(n - 1)(n - 2)\ldots 1$.
If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
risingfac(x::ZZ, n::Int)
risingfac(x::Int, n::Int)
\end{lstlisting}

\desc{Return the rising factorial of $x$, i.e. $x(x + 1)(x + 2)\ldots (x + n - 1)$.
If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
primorial(n::Int)
\end{lstlisting}

\desc{Return as a \code{ZZ} the primorial of $n$, i.e. the product of all primes
less than or equal to $n$. If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
fib(n::Int)
\end{lstlisting}

\desc{Return the $n$-th element of the Fibonacci sequence, starting with 
\code{fib(1) = 1}, \code{fib(2) = 1} and following the recursion 
\code{fib(n) = fib(n - 1) + fib(n - 2)} for $n \geq 3$.
We return fib$(0) = 0$. If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
binom(n::Int, k::Int)
\end{lstlisting}

\desc{Return as a \code{ZZ} the binomial coefficient $\frac{n!}{(n - k)!k!}$. If
$n, k < 0$ or $k > n$ we return $0$.}

\begin{lstlisting}
moebiusmu(x::ZZ)
\end{lstlisting}

\desc{Returns the M\"{o}bius mu function of $x$ as an \code{Int}. The value returned is
either $-1$, $0$ or $1$. If $x < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
jacobi(x::ZZ, y::ZZ)
\end{lstlisting}

\desc{Return the value of the Jacobi symbol $\ljk{x}{y}$. If $y \leq x$ or $x < 0$ we
throw a \code{DomainError()}.}

\begin{lstlisting}
sigma(x::ZZ, y::Int)
\end{lstlisting}

\desc{Return the value of the sigma function, i.e. $\sum_{0 < d \;| x} d^y$. If $y < 0$
we throw a \code{DomainError()}.}

\begin{lstlisting}
eulerphi(x::ZZ)
\end{lstlisting}

\desc{Return the value of the Euler phi function, i.e. the number of $0 < d \leq x$ such
that gcd$(d, x) = 1$. If $x < 0$ we throw a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of number theoretic and combinatorial functions.

\begin{lstlisting}
if isprime(ZZ(13))
   println("13 is prime")
end

n = fac(100)
s = sigma(ZZ(128), 10)
a = eulerphi(ZZ(12480))
\end{lstlisting}

\subsection{Polynomial rings}

Nemo has a parametric polynomial type (called \code{Poly}). There's not any need to deal
directly with the type, as we provide a function \code{PolynomialRing} for constructing
it.

For completeness, we describe here how the \code{Poly} type works. The user not interested
in the ugly internals can skip forward to the section on constructors.

The type takes two parameters, the first a ring $T$ on which it is parameterised, and a
symbol, representing the variable, e.g. the type of polynomials over the integers in $x$, 
i.e. the type of $\Z[x]$, is \code|Poly{ZZ, :x}|.

Internally, we specialise the polynomial type to use flint structures where available.
For example, we define an \code{fmpz_poly} type in Julia to mirror flint's \code{fmpz_poly}.

\begin{lstlisting}
type fmpz_poly <: Ring
   coeffs :: Ptr{Void}
   alloc :: Int
   length :: Int
end
\end{lstlisting}

Fortunately, as Julia will construct an object of this type on the heap, we end up with
precisely an \code{fmpz_poly_t} which can be passed directly to flint \code{fmpz_poly}
functions.

For generic polynomials, for which there is no flint type (e.g. polynomials over another
polynomial ring) we define a general Julia type

\begin{lstlisting}
type PolyStruct{T <: Ring}
   coeffs :: Array{T, 1}
   length :: Int
end
\end{lstlisting}

It simply contains an array of coefficients of type $T$, where $T$ is in the \code{Ring}
class, and a length (degree plus one).

To define our general \code{Poly} type we use a Julia union type to combine the flint
and generic types.

\begin{lstlisting}
type Poly{T <: Ring, S} <: Ring
   data :: Union(fmpz_poly, fmpz_mod_poly, PolyStruct{T})
end
\end{lstlisting}

\subsubsection{Constructors}

Because dealing with the Julia types directly is somewhat messy, we provide a simple
function to create the type of a polynomial in Nemo.

\begin{lstlisting}
PolynomialRing{T <: Ring}(::Type{T}, s::String)
\end{lstlisting}

\desc{This function takes a type $T$ which belongs to the \code|Ring| class 
(e.g. \code|T = ZZ|) and a string giving the string representation of a variable (e.g. 
\code|"x"|) and returns a tuple \code|(R, x)| consisting of the type of the polynomial
ring being constructed, \code|R|, and the degree $1$ polynomial \code|x| in this ring. 
Here \code|S| is the symbol corresponding to the string \code|s|.}

This is easier to understand by giving an example

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = (x^2 + 2x + 1)*y^3 + (x - 1)*y + 4x - 1
\end{lstlisting}

Notice that we can build up polynomials from the degree one polynomials \code{x} and
\code{y} returned by the calls to \code{PolynomialRing}. 

Another thing to note is that there is no reason why the variable \code{x} has to 
be the same as the string \code{"x"}. The latter is simply how \code{x} will print
when we evaluate it. Of course, in most situations it is convenient to use the same 
letter for the variable and for the string.

Once we have constructed a polynomial type \code|R = Poly{T, S}| as above, we can
use it to construct polynomials of various kinds.

\begin{lstlisting}
Poly{T <: Ring, S}()
\end{lstlisting}

\desc{Construct a polynomial of length $0$ of the given type.}

\begin{lstlisting}
Poly{T <: Ring, S}(a::Integer)
Poly{T <: Ring, S}(a::T)
\end{lstlisting}

\desc{Construct a polynomial of length $1$ whose constant coefficient is $a$ if
$a \neq 0$, otherwise construct the zero polynomial.}

\begin{lstlisting}
Poly(::Type{Poly{T <: Ring, S}}, a::Array{T, 1})
\end{lstlisting}

\desc{Construct a polynomial whose coefficients are given by the elements of the array
\code{a}, starting with the constant coefficient at index $1$. The array must be fully
initialised, otherwise an exception may result.}

\begin{lstlisting}
Poly{T <: Ring, S}(a::Poly{T, S})
\end{lstlisting}

\desc{Return a reference to the polynomial \code{a}.}

\begin{lstlisting}
Poly{T <: Ring, S, R <: Ring}(a::R)
\end{lstlisting}

\desc{Try to convert the value \code{a} to the polynomial type parameterised by 
\code{T} and the symbol, if possible, and return the value, else raise an error. 
This constructor is used to coerce polynomials and coefficients from subordinate rings up
into the polynomial ring.}

\textbf{Examples.}

Here are some examples of these constructors in action. Note that we don't actually
ever need to deal with the parameterised \code{Poly} type directly.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")
T, z = PolynomialRing(S, "z")

f = x^2 + y^3 + z + 1

g = S(2)

h = S(x^2 + 2x + 1)

j = T(x + 2)

k = Poly(S, [x, x + 2, x^2 + 3x + 1])

l = S(k)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
normalise{T <: Ring, S}(a::Poly{T, S}, len::Int)
\end{lstlisting}

\desc{Return the normalised length of the polynomial $a$ assuming its unnormalised
length is \code{len}. A polynomial is normalised if it is either length $0$ or its
leading coefficient is nonzero. This function is usually used internally.}

\begin{lstlisting}
coeff{T <: Ring, S}(a::Poly{T, S}, n::Int)
\end{lstlisting}

\desc{Return the coefficient of the degree $n$ term of the polnomial $a$, or zero
if it has none.}

\begin{lstlisting}
lead{T <: Ring, S}(a::Poly{T, S})
\end{lstlisting}

\desc{Return the leading coefficient of the polynomial $a$, or zero if $a$ has
length $0$.}

\begin{lstlisting}
isgen{T <: Ring, S}(a::Poly{T, S})
\end{lstlisting}

\desc{Return \code{true} if the polynomial $a$ is the generator (variable) of the
polynomial ring, otherwise return \code{false}.}

\begin{lstlisting}
zero{T <: Ring, S}(::Type{Poly{T, S}})
\end{lstlisting}

\desc{Return the additive identity $0$ in the given polynomial ring.}

\begin{lstlisting}
one{T <: Ring, S}(::Type{Poly{T, S}})
\end{lstlisting}

\desc{Return the multiplicative identity $1$ in the given polynomial ring.}

\begin{lstlisting}
gen{T <: Ring, S}(::Type{Poly{T, S}})
\end{lstlisting}

\desc{Return the generator (variable) of the given polynomial ring.}

\begin{lstlisting}
canonical_unit{T <: Ring, S}(a::Poly{T, S})
\end{lstlisting}

\desc{Used for canonicalising fractions. The function simply returns
\code{canonical_unit} of the leading coefficient.}

\textbf{Examples.}

Here are some examples of the basic manipulation functions.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

a = zero(R)
b = one(S)
c = gen(S)

f = x^2 + 2x + 1
g = lead(f)

h = x*y^2 + (x + 1)*y + 3
j = coeff(h, 2)

if isgen(x)
   println(x, " is the generator of the ", typeof(x))
end

k = canonical_unit(-x + 1)
m = canonical_unit(-x*y + x + 1)
\end{lstlisting}

\subsubsection{Binary operators}

The following binary operators are provided for polynomials. Note that
if both operands are not in the same polynomial ring, Nemo will try to
coerce them into one of the two rings before applying the operation.

\begin{lstlisting}
+{T <: Ring, S}(a::Poly{T, S}, b::Poly{T, S})
-{T <: Ring, S}(a::Poly{T, S}, b::Poly{T, S})
*{T <: Ring, S}(a::Poly{T, S}, b::Poly{T, S})
\end{lstlisting}

\textbf{Examples.}

Here are some examples of the binary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1
g = x^3 + 3x + 2
h = f + g
j = f*g

k = x*y^2 + (x + 1)*y + 3
l = (x + 1)*y + (x^3 + 2x + 2)
m = k - l

n = k*h
p = m - g
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following ad hoc binary operators are faster than first coercing all
operands into the polynomial ring.

\begin{lstlisting}
+{T <: Ring, S}(x::Poly{T, S}, y::Int)
+{T <: Ring, S}(x::Poly{T, S}, y::ZZ)
+{T <: Ring, S}(x::Int, y::Poly{T, S})
+{T <: Ring, S}(x::ZZ, y::Poly{T, S})
-{T <: Ring, S}(x::Poly{T, S}, y::Int)
-{T <: Ring, S}(x::Poly{T, S}, y::ZZ)
-{T <: Ring, S}(x::Int, y::Poly{T, S})
-{T <: Ring, S}(x::ZZ, y::Poly{T, S})
*{T <: Ring, S}(x::Poly{T, S}, y::Int)
*{T <: Ring, S}(x::Poly{T, S}, y::ZZ)
*{T <: Ring, S}(x::Int, y::Poly{T, S})
*{T <: Ring, S}(x::ZZ, y::Poly{T, S})
\end{lstlisting}

\textbf{Examples.}

Here are some examples of the ad hoc binary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1
g = x^3 + 3x + 2
h = f + 12
j = ZZ(3)*g

k = x*y^2 + (x + 1)*y + 3
l = (x + 1)*y + (x^3 + 2x + 2)
m = k - 4
n = ZZ(5) - l
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
=={T<: Ring, S}(x::Poly{T, S}, y::Poly{T, S})
\end{lstlisting}

Julia automatically provides a \code{!=} operator.

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1
g = x^3 + 3x + 1

if f != g
   println("f and g are not equal")
end

k = x*y^2 + (x + 1)*y + 3
l = x*y^2 + (x + 1)*y + 3

if k == l
   println("k is equal to l")
end
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following comparison operators are faster than first coercing the arguments
into one or the other ring.

\begin{lstlisting}
=={T <: Ring, S}(x::Poly{T, S}, y::Int)
=={T <: Ring, S}(x::Poly{T, S}, y::ZZ)
=={T<: Ring, S}(x::Int, y::Poly{T, S})
=={T<: Ring, S}(x::ZZ, y::Poly{T, S})
\end{lstlisting}

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1

if f != 1
   println("f is not equal to 1")
end

if S(1) == ZZ(1)
   println("S(1) is equal to ZZ(1)")
end
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{T <: Ring, S}(a::Poly{T, S})
\end{lstlisting}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1
g = -f

h = x*y^2 + (x + 1)*y + 3
j = -h
\end{lstlisting}

\subsubsection{Truncated operations}

\begin{lstlisting}
truncate{T <: Ring, S}(a::Poly{T, S}, n::Int)
\end{lstlisting}

\desc{Return the polynomial $a$ truncated to length $n$. If $n < 0$ we throw a
\code{DomainError()}.}

\begin{lstlisting}
mullow{T <: Ring, S}(a::Poly{T, S}, b::Poly{T, S}, n::Int)
\end{lstlisting}

\desc{Return the polynomial \code{a*b} truncated to length $n$. If $n < 0$ we
throw a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of truncated operations.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1
g = x^3 + 3x + 1
h = truncate(f, 2)
j = mullow(f, g, 3)

k = x*y^2 + (x + 1)*y + 3
l = (x + 1)*y + (x^3 + 2x + 2)
m = truncate(k, 1)
n = mullow(k, l, 4)
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: Ring, S}(a::Poly{T, S}, n::Int)
\end{lstlisting}

\desc{Return the polynomial $a^n$. If $n < 0$ we throw a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1
g = f^12

k = x*y^2 + (x + 1)*y + 3
l = k^5
\end{lstlisting}

\subsubsection{Modular arithmetic}

When \code{T} is a residue ring, we can reduce modulo a polynomial over
\code{T}. In this way we can do modular arithmetic with polynomials.

\begin{lstlisting}
mulmod{T <: Residue, S}(a::Poly{T, S}, b::Poly{T, S}, d::Poly{T, S})
\end{lstlisting}

\desc{Return $ab \pmod{d}$.}

\begin{lstlisting}
invmod{T <: Residue, S}(a::Poly{T, S}, d::Poly{T, S})
\end{lstlisting}

\desc{Return $a^{-1} \pmod{d}$. If an impossible inverse is encountered, an
exception is thrown.}

\begin{lstlisting}
powmod{T <: Residue, S}(a::Poly{T, S}, b::Int, d::Poly{T, S})
\end{lstlisting}

\desc{Return $a^b \pmod{d}$.}

Here are some examples of modular arithmetic.

\begin{lstlisting}
R = ResidueRing(ZZ, 487326487)
S, x = PolynomialRing(R, "x")

f = 3*x^2 + x + 2
g = 5*x^2 + 2*x + 1
h = 3*x^3 + 2*x^2 + x + 7

invmod(f, h)
mulmod(f, g, h)
powmod(f, 10, h)
\end{lstlisting}

\subsubsection{Exact division}

First we have exact division by a scalar.

\begin{lstlisting}
divexact{T <: Ring, S}(a::Poly{T, S}, b::T)
\end{lstlisting}

\desc{Return $a$ divided by $b$. The result is only meaningful if the division is
exact. If $b = 0$ we throw a \code{DivideError()}.}

Then we have division of a polynomial by another.

\begin{lstlisting}
divexact{T <: Ring, S}(a::Poly{T, S}, b::Poly{T, S})
\end{lstlisting}

\desc{Return $a$ divided by $b$. The result is only meaningful if the division is
exact. If $b = 0$ we throw a \code{DivideError()}. 

If \code{T} is a residue ring and the leading coefficient of $b$ is not invertible
in the \code{T}, an error will be thrown.} 

\textbf{Examples.}

Here are some examples of exact division.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1
g = x^3 + 3x + 1
h = divexact(f*g, f)
j = divexact(3*f, ZZ(3))

k = x*y^2 + (x + 1)*y + 3
l = (x + 1)*y + (x^3 + 2x + 2)
m = divexact(k*l, k)
\end{lstlisting}

\subsubsection{Euclidean division}

Over a residue ring we can define Euclidean division.

\begin{lstlisting}
mod{T <: Residue, S}(f::Poly{T, S}, g::Poly{T, S})
\end{lstlisting}

\desc{Return the Euclidean remainder of $f$ divided by $g$, i.e. $r$ such 
that $a = bq + r$ for some polynomial $r$ with deg$(r) <$ deg$(b)$. If 
$g = 0$ we throw a \code{DivideError()}.}

\begin{lstlisting}
divrem{T <: Residue, S}(f::Poly{T, S}, g::Poly{T, S})
\end{lstlisting}

\desc{Return the Euclidean quotient and remainder of $f$ divided by $g$, i.e.
a tuple \code{(q, r)} such that $a = bq + r$ with deg$(r) <$ deg$(b)$. If 
$g = 0$ we throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of Euclidean division.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)
S, x = PolynomialRing(R, "x")

f = x^2 + 2x + 1
g = x^3 + 3x + 1
h = mod(g, f)
q, r = divrem(g, f)

T = ResidueRing(S, x^3 + 3x + 1)
U, y = PolynomialRing(T, "y")

k = y^3 + x*y^2 + (x + 1)*y + 3
l = (x + 1)*y^2 + (x^3 + 2x + 2)
m = mod(k, l)
q, r = divrem(k, l)
\end{lstlisting}

\subsubsection{Pseudodivision}

Given two polynomials $a, b$, pseudodivision computes polynomials $q$ and $r$
with length$(r) <$ length$(b)$ such that
$$L^d a = bq + r,$$
where $d =$ length$(a) -$ length$(b) + 1$ and $L$ is the leading coefficient
of $b$.

We call $q$ the pseudoquotient and $r$ the pseudoremainder.

\begin{lstlisting}
pseudorem{T <: Ring, S}(a::Poly{T, S}, b::Poly{T, S})
\end{lstlisting}

\desc{Return the pseudoremainder of $a$ divided by $b$. If $b = 0$ we throw a 
\code{DivideError()}.}

\begin{lstlisting}
pseudodivrem{T <: Ring, S}(a::Poly{T, S}, b::Poly{T, S})
\end{lstlisting}

\desc{Return a tuple $(q, r)$ consisting of the pseudoquotient and pseudoremainder 
of $a$ divided by $b$. If $b = 0$ we throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of pseudodivision.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1
g = x^3 + 3x + 1
r = pseudorem(f, g)
q, r = pseudodivrem(f, g)

k = x*y^2 + (x + 1)*y + 3
l = (x + 1)*y + (x^3 + 2x + 2)
m = pseudorem(k, l)
m, n = pseudodivrem(k, l)
\end{lstlisting}

Note that pseudodivision is not always useful. In general it computes a
multiple of the quotient, and for example in the case of polynomials over a
residue ring, this may lead to meaningless results in the presence of zero
divisors. For example

\begin{lstlisting}
R = ResidueRing(ZZ, 6)
S, x = PolynomialRing(R, "x")
f = 3*x^5 + x^4 + 3*x^2 + 2
g = 2*x^3 + 5*x^2 + 2*x + 2
pseudorem(f, g)
\end{lstlisting}

Here Nemo returns \code{3*x^2}, which happens to be \code{3*g} in this
ring.

\subsubsection{Content, primitive part and GCD}

When the base ring provides a \code{gcd} function we can provide numerous
GCD related functions for polynomials over that ring.

\begin{lstlisting}
content{T <: Ring, S}(a::Poly{T, S})
\end{lstlisting}

\desc{Return the content of the polynomial $a$, i.e. the greatest common divisor
of all its coefficients, if this exists.}

\begin{lstlisting}
primpart{T <: Ring, S}(a::Poly{T, S})
\end{lstlisting}

\desc{Return the primitive part of the polynomial $a$, i.e. the polynomial
divided by its content, if it exists.}

\begin{lstlisting}
gcd{T <: Ring, S}(a::Poly{T, S}, b::Poly{T, S})
\end{lstlisting}

\desc{Return the greatest common divisor of the polynomials $a$ and $b$ if 
it exists.}

We allow GCD for polynomials over residue rings, e.g. over $\Z/n\Z$, even when
the residue ring has zero divisors. However, if an impossible inverse is
encountered during the computation, due to zero divisors, we throw an error.

\textbf{Examples.}

Here are some examples of content, primitive part and GCD.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1
g = x^3 + 3x + 1
h = x + 1
r = content(3*f)
s = primpart(3*f)
t = gcd(f*h, g*h)

k = x*y^2 + (x + 1)*y + 3
l = (x + 1)*y + (x^3 + 2x + 2)
m = y^2 + x + 1
n = content(k)
p = primpart(k*(x^2 + 1))
q = gcd(k*m, l*m)
\end{lstlisting}

\subsubsection{Evaluation}

\begin{lstlisting}
evaluate{T <: Ring, S}(a::Poly{T, S}, b::Int)
evaluate{T <: Ring, S}(a::Poly{T, S}, b::ZZ)
evaluate{T <: Ring, S}(a::Poly{T, S}, b::T)
\end{lstlisting}

\desc{Return the value of the polynomial $a$ evaluated at $b$.}

\textbf{Examples.}

Here are some examples of evaluation.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1
g = evaluate(f, 3)
h = evaluate(f, ZZ(10))

j = x*y^2 + (x + 1)*y + 3
k = evaluate(j, 3)
l = evaluate(j, x^2 + 2x + 1)
\end{lstlisting}

\subsubsection{Composition}

\begin{lstlisting}
compose{T <: Ring, S}(a::Poly{T, S}, b::Poly{T, S})
\end{lstlisting}

\desc{Return the composition of the polynomial $a$ with $b$, i.e. $a \circ b$.}

\textbf{Examples.}

Here are some examples of composition.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1
g = x^3 + 3x + 1
h = compose(f, g)

j = x*y^2 + (x + 1)*y + 3
k = (x + 1)*y + (x^3 + 2x + 2)
l = compose(j, k)
\end{lstlisting}

\subsubsection{Derivative}

\begin{lstlisting}
deriv{T <: Ring, S}(a::Poly{T, S})
\end{lstlisting}

\desc{Return the derivative of the polynomial $a$ with respect to its main
variable.}

\textbf{Examples.}

Here are some examples of computing derivatives.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1
g = deriv(f)

h = x*y^2 + (x + 1)*y + 3
j = deriv(h)
\end{lstlisting}

\subsubsection{Resultant}

\begin{lstlisting}
resultant{T <: Ring, S}(a::Poly{T, S}, b::Poly{T, S})
\end{lstlisting}

\desc{Return the resultant of the polynomials $a$ and $b$.}

\textbf{Examples.}

Here are some examples of computing resultants.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = 5x^2 + 2x + 1
g = 2x^3 + 3x + 1
h = resultant(f, g)

j = 3x*y^2 + (x + 1)*y + 3
k = 6(x + 1)*y + (x^3 + 2x + 2)
l = resultant(j, k)
\end{lstlisting}

\subsubsection{Discriminant}

\begin{lstlisting}
discriminant{T <: Ring, S}(a::Poly{T, S})
\end{lstlisting}

\desc{Compute the discriminant of the polynomial $a$.}

\textbf{Examples.}

Here are some examples of computing discriminants.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^2 + 2x + 1
g = discriminant(f)

h = x*y^2 + (x + 1)*y + 3
j = discriminant(h)
\end{lstlisting}

\subsubsection{Bezout identity}

The Bezout identity is the equivalent, for polynomials, of the extended GCD
in the case of the integers.

Given polynomials $a, b$, we can find polynomials $s, t$ such that
$$sa + bt = r,$$
where $r$ is the resultant of $a$ and $b$.

\begin{lstlisting}
bezout{T <: Ring, S}(a::Poly{T, S}, b::Poly{T, S})
\end{lstlisting}

\desc{Return a tuple $(r, s, t)$ such that $r$ is the resultant of $a$ and $b$
and with polynomials $s, t$ such that $r = as + bt$.}

\textbf{Examples.}

Here are some examples of computing the Bezout identity.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = 5x^2 + 2x + 1
g = 2x^3 + 3x + 1
r, s, t = bezout(f, g)

j = 3x*y^2 + (x + 1)*y + 3
k = 6(x + 1)*y + (x^3 + 2x + 2)
u, v, w = bezout(j, k)
\end{lstlisting}

\subsubsection{Special polynomials}

The following functions compute univariate special polynomials over \code{ZZ}.

\begin{lstlisting}
chebyshev_t{S}(::Type{Poly{ZZ, S}}, n::Int)
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $T_n(x)$, defined by 
$T_n(x) = \cos(n \cos^{-1}(x))$.}

\begin{lstlisting}
chebyshev_u{S}(::Type{Poly{ZZ, S}}, n::Int)
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $U_n(x)$, defined by 
$(n+1) U_n(x) = T'_{n+1}(x)$.}

\begin{lstlisting}
cyclotomic{S}(::Type{Poly{ZZ, S}}, n::Int)
\end{lstlisting}

\desc{Return the $n$th cyclotomic polynomial, defined as
$$\Phi_n(x) = \prod_{\omega} (x-\omega),$$ where $\omega$ runs over all the 
$n$th primitive roots of unity.}

\begin{lstlisting}
swinnerton_dyer{S}(::Type{Poly{ZZ, S}}, n::Int)
\end{lstlisting}

\desc{Return the Swinnerton-Dyer polynomial $S_n$, defined as the integer 
polynomial $$S_n = \prod (x \pm \sqrt{2} \pm \sqrt{3}
\pm \sqrt{5} \pm \ldots \pm \sqrt{p_n})$$ where $p_n$ denotes the $n$-th prime 
number and all combinations of signs are taken. This polynomial has degree $2^n$
and is irreducible over the integers (it is the minimal polynomial of 
$\sqrt{2} + \ldots + \sqrt{p_n}$)}

\begin{lstlisting}
cos_minpoly{S}(::Type{Poly{ZZ, S}}, n::Int)
\end{lstlisting}

\desc{Return the minimal polynomial of $2 \cos(2 \pi / n)$. For suitable choice of 
$n$, this gives the minimal polynomial of $2 \cos(a \pi)$ or $2 \sin(a \pi)$ for any
rational $a$.}

\begin{lstlisting}
theta_qexp{S}(::Type{Poly{ZZ, S}}, r::Int, n::Int)
\end{lstlisting}

\desc{Return the $q$-expansion to length $n$ of the Jacobi theta function raised to 
the power $r$, i.e. $\vartheta(q)^r$ where 
$\vartheta(q) = 1 + \sum_{k=1}^{\infty} q^{k^2}$.}

\begin{lstlisting}
eta_qexp{S}(::Type{Poly{ZZ, S}}, r::Int, n::Int)
\end{lstlisting}

\desc{Return the $q$-expansion to length $n$ of the Dedekind eta function (without 
the leading factor $q^{1/24}$) raised to the power $r$, i.e. $(q^{-1/24} \eta(q))^r 
= \prod_{k=1}^{\infty} (1 - q^k)^r$.

In particular, $r = -1$ gives the generating function of the partition function $p(k)$, 
and $r = 24$ gives, after multiplication by $q$, the modular discriminant $\Delta(q)$ 
which generates the Ramanujan tau function $\tau(k)$.}

\textbf{Examples.}

Here are some examples of computing special polynomials.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = chebyshev_t(R, 20)
g = chebyshev_u(R, 15)
h = cyclotomic(R, 120)
j = swinnerton_dyer(R, 5)
k = cos_minpoly(R, 30)
l = theta_qexp(R, 3, 30)
m = eta_qexp(R, 24, 30)
\end{lstlisting}

\subsection{Residue rings}

Nemo allows the construction of residue rings. 

There are two examples to keep in mind:

\begin{enumerate}
\item $\Z/n\Z$ for some positive integer $n$

\item $\Q[x]/(f)$ where $f$ is a polynomial in $\Q[x]$.
\end{enumerate}

Currently we only allow construction of residue rings of the form $R/(r)$ where
$R$ is a ring and $(r)$ is a principal ideal generated by an element $r \in R$. 

In (1) above the principal ideal is $(n)$ and in (2) the principal
ideal is $(f)$.

We don't require the ideal $(r)$ to be maximal or prime (corresponding in the
commutative case to residue rings that are fields and integral domains 
respectively). 

Instead, we allow $r$ to be any nonzero element of $R$, but raise an exception
every time a computation in $R/(r)$ requires computing an impossible inverse.

The type for a residue ring in Nemo is \code{Residue}. But again there is no
need to deal directly with the type at all, as we provide a function
\code{ResidueRing} for constructing it.

As usual, we give a description of the ugly internals which can be skipped if
desired.

The type takes two parameters, the first a ring \code{T} on which it is
parameterised and the second a symbol \code{S}. This symbol will always be
a unique symbol automatically generated by Nemo, which the user can't see. It
is used to identify the variable which holds the modulus of the type.

For example, suppose we construct $\Z/n\Z$ where $n$ is a bignum integer. Then
the type would be something like \code|Residue{ZZ, :##residue#418}| where the
hidden variable \code{##residue#418} contains the bignum integer $n$.

Here is the actual Julia type definition

\begin{lstlisting}
type Residue{T <: Ring, S} <: Ring
   data::T
end
\end{lstlisting}

Note that the modulus is not stored as a data field inside the type, but is
a type parameter, \code{S}. This allows for an extremely efficient 
representation of values of \code{Residue} type.

For example, a polynomial whose coefficients are in $\Z/n\Z$ can be 
represented as an array of values of type \code{Residue}, each of which holds
only a single integer for the residue, not an integer for the residue and
another for the modulus. This results in a factor of two space saving when
creating arrays of values of type \code{Residue}, for a fixed modulus $n$.

\subsubsection{Constructors}

To make it easy to deal with the \code{Residue} type in Nemo, we provide a
function for constructing the type of a residue ring

\begin{lstlisting}
ResidueRing{T <: Ring}(::Type{T}, r::T)
ResidueRing{T <: Ring}(::Type{T}, r::Int)
\end{lstlisting}

\desc{This function takes a type \code{T} which belongs to the \code{Ring}
class (e.g. \code{T = ZZ}) and an element \code{r} of the ring \code{T} (or
an integer that can be coerced into \code{T}). It returns the type 
corresponding to the residue ring $T/(r)$.}

\begin{lstlisting}
Residue{T <: Ring, S}(a::T)
Residue{T <: Ring, S}(a::Int)  
\end{lstlisting}

\desc{Create a residue congruent to $a$. The value $a$ is first reduced
modulo the modulus of the residue ring.}

\begin{lstlisting}
Residue{T <: Ring, S}(a::Residue{T, S})  
\end{lstlisting}

\desc{Return a reference to the residue $a$. No copy of the data is made.}

\begin{lstlisting}
Residue{T <: Ring, S}()
\end{lstlisting}

\desc{Create a new residue, which is congruent to $0$.}

\textbf{Examples.}

Here are some examples of constructing residue rings and elements in them.

\begin{lstlisting}
R = ResidueRing(ZZ, 16453889)

f = R(123)
g = R(f)
h = R(ZZ(12))
k = R()

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

m = T(x^4)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
modulus{T <: Ring, S}(::Type{Residue{T, S}})
\end{lstlisting}

\desc{Return the modulus of the given residue ring.}

\begin{lstlisting}
zero{T <: Ring, S}(::Type{Residue{T, S}})
\end{lstlisting}

\desc{Return the additive identity of the given residue ring.}

\begin{lstlisting}
one{T <: Ring, S}(::Type{Residue{T, S}})
\end{lstlisting}

\desc{Return the multiplicative identity of the given residue ring.}

\begin{lstlisting}
canonical_unit{T <: Ring, S}(a::Residue{T, S})
\end{lstlisting}

\desc{Used for canonicalising fractions. The function simply returns $a$. No
check is performed to check that $a$ is actually invertible.}

\textbf{Examples.}

Here are some examples of basic manipulation of residue rings.

\begin{lstlisting}
R = ResidueRing(ZZ, 16453889)

f = modulus(R)
g = zero(R)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

h = one(T)

k = canonical_unit(R(11))
m = canonical_unit(T(x + 1))
\end{lstlisting}

\subsubsection{Unary operations}

\begin{lstlisting}
-{T <: Ring, S}(a::Residue{T, S})
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R = ResidueRing(ZZ, 16453889)

f = -R(12345)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

h = -T(x^5 + 1)
\end{lstlisting}

\subsubsection{Binary operations and functions}

The following binary operators and functions are defined for residue rings.

\begin{lstlisting}
+{T <: Ring, S}(a::Residue{T, S}, b::Residue{T, S})
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-{T <: Ring, S}(a::Residue{T, S}, b::Residue{T, S})
\end{lstlisting}

\desc{Return $a - b$.}

\begin{lstlisting}
*{T <: Ring, S}(a::Residue{T, S}, b::Residue{T, S})
\end{lstlisting}

\desc{Return $ab$.}

\begin{lstlisting}
divexact{T <: Ring, S}(a::Residue{T, S}, b::Residue{T, S})
\end{lstlisting}

\desc{Return $a$ divided by $b$. If an impossible inverse is encounted
an exception is thrown.}

\begin{lstlisting}
gcd{T <: Ring, S}(a::Residue{T, S}, b::Residue{T, S})
\end{lstlisting}

\desc{Return the greatest common divisor of $a$ and $b$. 

Recall that $a$ and $b$ are represented by values $a'$ and $b'$ in $T$, 
say. We define the greatest common divisor of $a$ and $b$ to be the 
residue class of gcd$($gcd$(a', b'), m)$ when that is defined, where 
$m$ is the modulus of the residue ring.

This definition does not depend on the choice of representatives of
$a$ and $b$.}

\textbf{Examples.}

Here are some examples of binary operators and functions.

\begin{lstlisting}
R = ResidueRing(ZZ, 12)

f = R(4)
g = R(6)

h = f + g
j = f - g
k = f*g
l = gcd(f, g)

Q = ResidueRing(ZZ, 7)

a = Q(3)
b = Q(4)

m = divexact(a*b, a)

S, x = PolynomialRing(Q, "x")
T = ResidueRing(S, x^3 + 3x + 1)

n = T(x^5 + 1)
p = T(x^2 + 2x + 1)

q = n + p
r = n - p
s = n*p
t = divexact(n*p, p)
u = gcd(n, p)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

In a residue ring $R$ over a ring $T$, with modulus $m$, it is convenient
to think of $n \in \Z$ as corresponding to $1$ added to itself $n$ times
in $T$ then reduced modulo $m$.

This allows us to efficiently define the following ad hoc operators, which
effectively make the integers $n \in \Z$ a convenient notation for certain
elements of the residue ring $R$.

\begin{lstlisting}
+{T <: Ring, S}(a::Residue{T, S}, b::Int)
+{T <: Ring, S}(a::Int, b::Residue{T, S})
+{T <: Ring, S}(a::Residue{T, S}, b::ZZ)
+{T <: Ring, S}(a::ZZ, b::Residue{T, S})
\end{lstlisting}

\desc{Return $a + b$ with the integer operand thought of as an element of 
the given residue ring.}

\begin{lstlisting}
-{T <: Ring, S}(a::Residue{T, S}, b::Int)
-{T <: Ring, S}(a::Int, b::Residue{T, S})
-{T <: Ring, S}(a::Residue{T, S}, b::ZZ)
-{T <: Ring, S}(a::ZZ, b::Residue{T, S})
\end{lstlisting}

\desc{Return $a - b$ with the integer operand thought of as an element of 
the given residue ring.}

\begin{lstlisting}
*{T <: Ring, S}(a::Residue{T, S}, b::Int)
*{T <: Ring, S}(a::Residue{T, S}, b::ZZ)
\end{lstlisting}

\desc{Return $ab$, i.e. the element $a$ added to itself $b$ times.}

\begin{lstlisting}
*{T <: Ring, S}(a::Int, b::Residue{T, S})
*{T <: Ring, S}(a::ZZ, b::Residue{T, S})
\end{lstlisting}

\desc{Return $ab$, i.e. the element $b$ added to itself $a$ times.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)

b = a + 3
c = 3 - a
d = 5a

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)
g = f + 4
h = 4 - f
k = f*5
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
=={T, S}(x::Residue{T, S}, y::Residue{T, S})
\end{lstlisting}

\desc{Return \code{true} if $x = y$ arithmetically in the given residue ring, 
otherwise return false.}

Julia automatically defines a \code{!=} operator.

\textbf{Examples.}

Here are some examples of comparisons.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)
b = a
c = R(2)

b == a
c != a

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)
g = 8f
h = f + g

f == g
h != g
\end{lstlisting}

\subsubsection{Ad hoc comparison}

Thinking of integers as corresponding to elements of a residue ring, we
can define the following ad hoc comparison operators.

\begin{lstlisting}
=={T, S}(x::Residue{T, S}, y::Int)
=={T, S}(x::Residue{T, S}, y::ZZ)
\end{lstlisting}

\desc{Given $x \in R$ where $R$ is the given residue ring, return \code{true} 
if $x = y.1$ in $R$, otherwise return \code{false}.}

\begin{lstlisting}
=={T, S}(x::ZZ, y::Residue{T, S})
=={T, S}(x::Int, y::Residue{T, S})
\end{lstlisting}

\desc{Given $y \in R$ where $R$ is the given residue ring, return \code{true} 
if $x.1 = y$ in $R$, otherwise return \code{false}.}

Julia automatically provides corresponding \code{!=} operators.

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)

a == 3
4 != a

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)

f != 5
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: Ring, S}(a::Residue{T, S}, b::Int)
\end{lstlisting}

\desc{Return $a^b$.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)

b = a^5

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)

g = f^100
\end{lstlisting}

\subsubsection{Inversion}

So long as we don't encounter an impossible inverse, we can
invert an element in a residue ring $R = T/(m)$, if $T$ is a
Euclidean ring, i.e. if we have a \code{gcd} function in $T$.

\begin{lstlisting}
inv{T <: Ring, S}(a::Residue{T, S})
\end{lstlisting}

\desc{Return the multiplicative inverse of $a$ in the given residue
ring, i.e. return an element $b$ such that $ab = 1$ in the residue ring,
if such exists. If an impossible inverse is encountered during the
computation, we throw an exception.}

\textbf{Examples.}

Here are some examples of computing inverses.

\begin{lstlisting}
R = ResidueRing(ZZ, 49)

a = R(5)

b = inv(a)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)

g = inv(f)
\end{lstlisting}

\section{The Fields module}

Nemo provides various constructions of fields. To make use of this 
functionality simply import the \code{Fields} module

\begin{lstlisting}
using Fields
\end{lstlisting}

The first thing the \code{Fields} module does is define the abstract
type \code{Field} like so

\begin{lstlisting}
abstract Field <: Ring
\end{lstlisting}

This means fields can be used anywhere that a more general ring can be used
in Nemo.

Nemo fields provide the \code{/} operator, and genuine fields are closed under
the action of this operator, except for division by zero.

\subsection{Fraction fields}

We allow the construction of a fraction field over any ring in Nemo. Not all
such constructions make sense. Typically it only makes sense to construct the
fraction field of an integral domain. However, so long as zero divisors are
avoided there is nothing stopping one constructing the fraction field of a
more general Euclidean ring in Nemo.

Specifically, a ring must provide a \code{gcd} function before we can take its
fraction field. This is required for canonicalisation.

The type of an element of a fraction field in Nemo is \code{Fraction}. However
the user need never deal directly with the type, as we provide convenient
functions for constructing objects of this type.

The reader not interested in the internal details of the \code{Fraction} type
can skip ahead to the section on constructors.

The definition of the \code{Fraction} type in Julia is very simple

\begin{lstlisting}
type Fraction{T <: Ring} <: Field
   num :: T
   den :: T
end
\end{lstlisting}

It is parameterised over a ring type \code{T} and contains a numerator 
\code{num} and denominator \code{den}, both of type \code{T}.

The inner constructor for the \code{Fraction} type does not try to canonicalise
the fraction, but all other constructors should produce a canonicalised
fraction, where possible.

In order to canonicalise we divide both numerator and denominator by their
greatest common divisor. We also divide by \code{canonical_unit(den)} where
\code{den} is the denominator. This allows us to easily check equality of
fractions.

The \code{canonical_unit} function must have the properties

\begin{lstlisting}
canonical_unit(u) == u
canonical_unit(a*b) == canonical_unit(a)*canonical_unit(b)
\end{lstlisting}

for all values $a$ and $b$ in the ring \code{T} and $u$ any invertible element
in \code{T}. Moreover, \code{canonical_unit} must always return an invertible
element in the ring \code{T}.

We overload the \code{/} operator in Nemo for rings whose fraction field can
be taken (e.g. \code{ZZ} and \code|Poly{T, S}|), so that elements of the
fraction field of a ring can be constructed directly, without first
constructing the type.

For example if we have

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

s = (x + 1)/(x^2 + 1)
\end{lstlisting}

then the value $s$ belongs to the fraction field of $R$ automatically, even
though this field has not been constructed yet.

Currently, before \code{Fields} is imported, the default Julia behaviour of
\code{/} when passed values of type \code{Int} is to perform floating point
division (this will be changed in a later version of Nemo). However, after 
\code{Fields} has been imported, we override this so that it constructs an
element of the fraction field of \code{ZZ}, e.g. \code{1/2} yields a 
multiprecision fraction, not a floating point value.

The \code{/} operator doubles as a division operator when passed operands
in a fraction field.

In Nemo, we consider the fraction field of a field to be itself.

\subsubsection{Constructors}

We provide a convenient function for constructing a fraction field of a ring in
Nemo.

\begin{lstlisting}
FractionField{T <: Ring}(::Type{T})
\end{lstlisting}

\desc{Given a type \code{T} in the \code{Ring} class, this function returns a
type corresponding to its fraction field.}

There are also numerous constructors for generating elements in the fraction
field.

\begin{lstlisting}
Fraction{T <: Ring}(a :: T, b :: T)
\end{lstlisting}

\desc{This is the unadorned inner constructor. It does not try to canonicalise
or check for division by zero. It is mainly used internally to actually 
construct the value with $a$ as numerator and $b$ as denominator.}

\begin{lstlisting}
Fraction{T <: Ring}()
\end{lstlisting}

\desc{Return the value $0/1$ in the fraction field of the ring $T$.}

\begin{lstlisting}
Fraction{T <: Ring}(a::Integer)
\end{lstlisting}

\desc{Return the value $a/1$ in the fraction field of the ring $T$, i.e.
$1/1$ added to itself $a$ times.}

\begin{lstlisting}
Fraction{T <: Ring}(a::T)
\end{lstlisting}

\desc{Return the value $a/1$ in the fraction field of the ring $T$.}

\begin{lstlisting}
Fraction{T <: Ring}(a::Fraction{T})
\end{lstlisting}

\desc{Return a reference to the value $a$. No copy of the data is made.}

We also provide a simpler way of constructing elements of a fraction field
without needing to first construct the type of the fraction field. We use
the division operator.

\begin{lstlisting}
/(x::Int, y::Int)
/(x::ZZ, y::ZZ)
\end{lstlisting}

\desc{Return the value $x/y$ in the fraction field of \code{ZZ}. The fraction
is canonicalised, i.e. reduced to lowest terms with positive denominator. If
$y = 0$ we throw a \code{DivideError()}.}

\begin{lstlisting}
/{T <: Ring, S}(x::Poly{T, S}, y::Poly{T, S})
\end{lstlisting}

\desc{Return the value $x/y$ in the fraction field of the given polynomial
ring. The fraction is canonicalised, i.e. reduced to lowest terms with the
numerator and denominator normalised by dividing both by the
\code{canonical_unit} of the leading coefficient of the denominator. For
example, for polynomials over the integers, the denominator will have
positive leading coefficient. For polynomials over a field, the denominator
will be a monic polynomial. If $y = 0$ we throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of constructors for fraction fields.

\begin{lstlisting}
R = FractionField(ZZ)

a = R(ZZ(3), ZZ(2))

S, x = PolynomialRing(ZZ, "x")
T = FractionField(S)

b = T(3)
c = T(ZZ(7))
d = T(x + 2)
f = T(d)
g = T()

h = 2/3
k = ZZ(5)/ZZ(7)
m = (x + 3)/(x^2 + 2)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
num{T <: Ring}(a::Fraction{T})
\end{lstlisting}

\desc{Return the numerator of the fraction $a$.}

\begin{lstlisting}
den{T <: Ring}(a::Fraction{T})
\end{lstlisting}

\desc{Return the denominator of the fraction $a$.}

\begin{lstlisting}
zero{T <: Ring}(::Type{Fraction{T}})
\end{lstlisting}

\desc{Return the additive identity of the fraction field of the ring $T$.}

\begin{lstlisting}
one{T <: Ring}(::Type{Fraction{T}})
\end{lstlisting}

\desc{Return the multiplicative identity of the fraction field of the ring 
$T$.}

\begin{lstlisting}
canonical_unit{T}(a::Fraction{T})
\end{lstlisting}

\desc{Used for canonicalising fractions. This function simply returns $a$.}

\textbf{Examples.}

Here are some examples of constructors for fraction fields.

\begin{lstlisting}
R = FractionField(ZZ)
S, x = PolynomialRing(ZZ, "x")

a = num(4/6)
b = den((x + 1)/(-x^2 + 1))

c = zero(R)
d = one(S)
f = canonical_unit((x + 1)/(-x^2 + 1))
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{T <: Ring}(a::Fraction{T})
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -(4/6)
b = -((x + 1)/(-x^2 + 1))
\end{lstlisting}

\subsubsection{Comparison operators}

\begin{lstlisting}
=={T}(x::Fraction{T}, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $x$ equals the fraction $y$, else
return \code{false}.}

\textbf{Examples.}

Here are some examples of comparisons.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -(4/6)
b = -((x + 1)/(-x^2 + 1))

a == -2/3
b == 1/(x - 1)
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following comparison operators are faster than first coercing both
operands into the fraction field.

\begin{lstlisting}
=={T}(x::Fraction{T}, y::T)
\end{lstlisting}

\desc{Return \code{true} if the fraction $x$ equals the fraction $y/1$, else
return \code{false}.}

\begin{lstlisting}
=={T}(x::T, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $y$ equals the fraction $x/1$, else
return \code{false}.}

\begin{lstlisting}
=={T <: Ring}(x::Fraction{T}, y::Int)
=={T <: Ring}(x::Fraction{T}, y::ZZ)
\end{lstlisting}

\desc{Return \code{true} if the numerator of the fraction $x$ is equal to $y$
in the ring $T$ and the denominator is $1$, otherwise return \code{false}.}

\begin{lstlisting}
=={T <: Ring}(x::Int, y::Fraction{T})
=={T <: Ring}(x::ZZ, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the numerator of the fraction $y$ is equal to $x$
in the ring $T$ and the denominator is $1$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = 1/(x - 1)

1/a == x - 1
4/2 == 2
ZZ(3) == 6/2
1 == one(S)
\end{lstlisting}

\subsubsection{Binary operators and functions}

The following binary operators are available for elements of fraction fields.
All of the functions canonicalise their outputs.

\begin{lstlisting}
+{T <: Ring}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-{T <: Ring}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a - b$.}

\desc{Return $a + b$.}

\begin{lstlisting}
*{T <: Ring}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a*b$.}

\begin{lstlisting}
/{T <: Ring}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/b$, in the field of fractions of $T$.}

\begin{lstlisting}
divexact{T <: Ring}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{An alias for $a/b$.}

\begin{lstlisting}
gcd{T <: Ring}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $c/d$ where $c$ is the GCD of the numerators of $a$ and $b$ and
$d$ is the GCD of their denominators.}

\textbf{Examples.}

Here are some examples of binary operators and functions.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -2/3 + 3/7
b = (x + 1)/(-x^2 + 1) - x/(2x + 1)
c = (5/3)*(7/2)
d = a/c
f = gcd(b, (x + 1)/(x - 1))
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following binary operators are more efficient than simply coercing both
arguments into the fraction field. All functions canonicalise their outputs.

\begin{lstlisting}
+{T <: Ring}(a::Fraction{T}, b::Int)
+{T <: Ring}(a::Fraction{T}, b::ZZ)
+{T <: Ring}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a + b/1$.}

\begin{lstlisting}
+{T <: Ring}(a::Int, b::Fraction{T})
+{T <: Ring}(a::ZZ, b::Fraction{T})
+{T <: Ring}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/1 + b$.}

\begin{lstlisting}
-{T <: Ring}(a::Fraction{T}, b::Int)
-{T <: Ring}(a::Fraction{T}, b::ZZ)
-{T <: Ring}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a - b/1$.}

\begin{lstlisting}
-{T <: Ring}(a::Int, b::Fraction{T})
-{T <: Ring}(a::ZZ, b::Fraction{T})
-{T <: Ring}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/1 - b$.}

\begin{lstlisting}
*{T <: Ring}(a::Fraction{T}, b::Int)
*{T <: Ring}(a::Fraction{T}, b::ZZ)
*{T <: Ring}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a * b/1$.}

\begin{lstlisting}
*{T <: Ring}(a::Int, b::Fraction{T})
*{T <: Ring}(a::ZZ, b::Fraction{T})
*{T <: Ring}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/1 * b$.}

\begin{lstlisting}
/{T <: Ring}(a::Fraction{T}, b::Int)
/{T <: Ring}(a::Fraction{T}, b::ZZ)
/{T <: Ring}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a / (b/1)$.}

\begin{lstlisting}
/{T <: Ring}(a::Int, b::Fraction{T})
/{T <: Ring}(a::ZZ, b::Fraction{T})
/{T <: Ring}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $(a/1) / b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -2/3
b = (x + 1)/(-x^2 + 1)

c = a + 2
d = ZZ(3) - a

e = b*(x + 1)
f = a/5
g = (x + 1)/b
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: Ring}(a::Fraction{T}, b::Int)
\end{lstlisting}

\desc{Return $a^b$.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -2/3
b = (x + 1)/(-x^2 + 1)

c = a^12
d = b^-12
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv{T <: Ring}(a::Fraction{T})
\end{lstlisting}

\desc{Return $1/a$.}

\textbf{Examples.}

Here are some examples of inversion.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -2/3
b = (x + 1)/(-x^2 + 1)

c = inv(a)
d = inv(b)
\end{lstlisting}

\end{document}
