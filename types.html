<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types in Nemo · AbstractAlgebra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractAlgebra.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">AbstractAlgebra.jl</a></li><li><a class="toctext" href="about.html">Nemo</a></li><li class="current"><a class="toctext" href="types.html">Types in Nemo</a><ul class="internal"><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#The-abstract-type-hierarchy-in-Nemo-1">The abstract type hierarchy in Nemo</a></li><li><a class="toctext" href="#Why-types-aren&#39;t-enough-1">Why types aren&#39;t enough</a></li><li><a class="toctext" href="#More-complex-example-of-parent-objects-1">More complex example of parent objects</a></li><li><a class="toctext" href="#Concrete-types-in-Nemo-1">Concrete types in Nemo</a></li></ul></li><li><a class="toctext" href="constructors.html">Constructing mathematical objects in Nemo</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="types.html">Types in Nemo</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Types in Nemo</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Types-in-Nemo-1" href="#Types-in-Nemo-1">Types in Nemo</a></h1><p>On this page we discuss the type hierarchy in Nemo and a concept known as parents. These details are quite technical and should be skipped or skimmed by new users of Julia/Nemo. Types are almost never dealt with directly when scripting Nemo to do mathematical computations. </p><p>In contrast, Nemo developers will certainly want to know how we model mathematical objects and the rings, fields, groups, etc. that they belong to in Nemo.</p><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>Julia provides two levels of types that we make use of</p><ul><li><p>abstract types</p></li><li><p>concrete types</p></li></ul><p>Concrete types are just like the usual types everyone is familiar with from C or C++.</p><p>Abstract types can be thought of as collections of types. They are used when writing generic functions that should work for any type in the given collection.</p><p>To write a generic function that accepts any type in a given collection of types, we first create an abstract type. Then we create the individual concrete types that belong to that abstract type. A generic function can then be constructed with a type parameter, <code>T</code> say, similar to a template parameter in C++. The main difference is that we can specify which abstract type our type parameter <code>T</code> must belong to.</p><p>We use the symbol <code>&lt;:</code> in Julia to determine that a given type belongs to a given abstract type. For example the built-in Julia type <code>Int64</code> for 64 bit machine integers belongs to the Julia abstract type <code>Integer</code>. Thus <code>Int &lt;: Integer</code> returns <code>true</code>.</p><p>Here is some Julia code illustrating this with a more complex example. We create an abstract type called <code>Shape</code> and two user defined concrete types <code>square</code> and <code>circle</code> belonging to <code>Shape</code>. We then show how to write methods that accept each of the concrete types and then show how to write a generic function for any type <code>T</code> belonging to the abstract type <code>Shape</code>.</p><p>Note that in the type definitions of <code>square</code> and <code>circle</code> we specify that those types belong to the abstract type <code>Shape</code> using the <code>&lt;:</code> operator.</p><pre><code class="language-none">abstract Shape

type square &lt;: Shape
   width::Int
   border_thickness::Int
end

type circle &lt;: Shape
   centre::Tuple{Int, Int}
   radius::Int
   border_thickness::Int
end

function area(s::square)
   return s.width^2
end

function area(s::circle)
   return pi*s.radius^2
end

function border_thickness{T &lt;: Shape}(s::T)
   return s.border_thickness
end

s = square(3, 1)
c = circle((3, 4), 2, 2)

area(s)
area(c)
border_thickness(s)
border_thickness(c)</code></pre><h2><a class="nav-anchor" id="The-abstract-type-hierarchy-in-Nemo-1" href="#The-abstract-type-hierarchy-in-Nemo-1">The abstract type hierarchy in Nemo</a></h2><p>Abstract types in Julia can also belong to one another in a hierarchy. For example, the <code>Nemo.Field</code> abstract type belongs to the <code>Nemo.Ring</code> abstract type. An object representing a field in Nemo has type belonging to <code>Nemo.Field</code>. But because we define the inclusion <code>Nemo.Field &lt;: Nemo.Ring</code> in Nemo, the type of such an object also automatically belongs to <code>Nemo.Ring</code>. This means that any generic function in Nemo which is designed to work with ring objects will certainly also work with field objects.</p><p>In Nemo we also distinguish between the elements of a field, say, and the field itself, and similarly for groups and rings and all other kinds of domains in Nemo. For example, we have an object of type <code>GenPolyRing</code> to model a generic polynomial ring, and elements of that polynomial ring would have type <code>GenPoly</code>. </p><p>In order to model this distinction between elements and the domains they belong to, Nemo has two main branches in its abstract type hierarchy, as shown in the following diagram. One branch consists of the abstract types for the domains available in Nemo and the other branch is for the abstract types for elements of those domains. </p><p><img src="img/types.png" alt="alt text"/></p><p>All objects in Nemo, whether they represent rings, fields, groups, sets, etc. on the one hand, or ring elements, field elements, etc. on the other hand, have concrete types that belong to one of the abstract types shown above.</p><h2><a class="nav-anchor" id="Why-types-aren&#39;t-enough-1" href="#Why-types-aren&#39;t-enough-1">Why types aren&#39;t enough</a></h2><p>Naively, one may expect that rings in Nemo can be modeled as types and their elements as objects with the given type. But there are various reasons why this is not a good model.</p><p>As an example, consider the ring <span>$R = \mathbb{Z}/n\mathbb{Z}$</span> for a multiprecision integer <span>$n$</span>. If we were to model the ring <span>$R$</span> as a type, then the type would somehow need to contain the modulus <span>$n$</span>. This is not possible in Julia, and in fact it is not desirable either.</p><p>Julia dispatches on type, and each time we call a generic function with different types, a new version of the function is compiled at runtime for performance. But this would be a disaster if we were writing a multimodular algorithm, say. In such an algorithm many rings <span>$\mathbb{Z}/n\mathbb{Z}$</span> would be needed and every function we use would be recompiled over and over for each different <span>$n$</span>. This would result  in a huge delay as the compiler is invoked many times.</p><p>For this reason, the modulus <span>$n$</span> needs to be attached to the <em>elements</em> of the ring, not to type associated with those elements.</p><p>But now we have a problem. How do we create new elements of the ring <span>$\mathbb{Z}/n\mathbb{Z}$</span> given only the type? Suppose all rings <span>$\mathbb{Z}/n\mathbb{Z}$</span> were represented by the same type <code>Zmod</code> say. How would we create <span>$a = 3 \pmod{7}$</span>? We could not write <code>a = Zmod(3)</code> since the modulus <span>$7$</span> is not contained in the type <code>Zmod</code>.</p><p>We could of course use the notation <code>a = Zmod(3, 7)</code>, but this would make implementation of generic algorithms very difficult, as they would need to distinguish the case where constructors take a single argument, such as <code>a = ZZ(7)</code> and cases where they take a modulus, such as <code>a = Zmod(3, 7)</code>.</p><p>The way we get around this in Nemo is to have special (singleton) objects that act like types, but are really just ordinary Julia objects. These objects, called <em>parent</em> objects can contain extra information, such as the modulus <span>$n$</span>. </p><p>In order to create new elements of <span>$\mathbb{Z}/n\mathbb{Z}$</span> as above, we overload the <code>call</code> operator for the parent object, making it callable. Making a parent object callable is exactly analogous to writing a constructor for a type.</p><p>In the following Nemo example, we create the parent object <code>R</code> corresponding to the ring <span>$\mathbb{Z}/7\mathbb{Z}$</span>. We then create a new element <code>a</code> of this ring by calling the parent object <code>R</code>, just as though <code>R</code> were a type with a constructor accepting an <code>Int</code> parameter. </p><pre><code class="language-none">R = ResidueRing(ZZ, 7)
a = R(3)</code></pre><p>This example creates the element <span>$a = 3 \pmod{7}$</span>. </p><p>The important point is that unlike a type, a parent object such as <code>R</code> can contain additional information that a type cannot contain, such as the modulus <span>$7$</span> of the ring in this example, or context objects required by C libraries in other examples.</p><h2><a class="nav-anchor" id="More-complex-example-of-parent-objects-1" href="#More-complex-example-of-parent-objects-1">More complex example of parent objects</a></h2><p>Here is some Julia/Nemo code which constructs a polynomial ring over the integers, a polynomial in that ring and then does some introspection to illustrate the various relations between the objects and types.</p><pre><code class="language-none">julia&gt; using Nemo

julia&gt; R, x = ZZ[&quot;x&quot;]
(Univariate Polynomial Ring in x over Integer Ring,x)

julia&gt; f = x^2 + 3x + 1
x^2+3*x+1

julia&gt; typeof(R)
Nemo.FmpzPolyRing

julia&gt; typeof(f)
Nemo.fmpz_poly

julia&gt; parent(f)
Univariate Polynomial Ring in x over Integer Ring

julia&gt; typeof(R) &lt;: PolyRing
true

julia&gt; typeof(f) &lt;: PolyElem
true

julia&gt; parent(f) == R
true</code></pre><h2><a class="nav-anchor" id="Concrete-types-in-Nemo-1" href="#Concrete-types-in-Nemo-1">Concrete types in Nemo</a></h2><p>Finally we come to all the concrete types in Nemo. </p><p>These are of two main kinds: those for generic constructions (e.g. generic polynomials over an arbitrary ring) and those for specific implementations, usually provided by a C library (e.g. polynomials over the integers, provided by Flint).</p><p>Below we give the type of each kind of element available in Nemo. In parentheses we list the types of their corresponding parent objects. Note that these are the types of the element objects and parent objects respectively, not the abstract types to which these types belong, which the reader can easily guess. </p><p>For example, <code>fmpz</code> belongs to the abstract type <code>RingElem</code> and <code>FlintIntegerRing</code> belongs to <code>Ring</code>. Similarly <code>Poly{T}</code> belongs to <code>PolyElem</code> whereas <code>PolynomialRing{T}</code> belongs to <code>PolyRing</code>. We also have that <code>fmpz_poly</code> belongs to <code>PolyElem</code> and <code>FmpzPolyRing</code> belongs to <code>PolyRing</code>, and so on.</p><p>All the generic types are parameterised by a type <code>T</code> which is the type of the <em>elements</em> of the ring they are defined over. </p><ul><li><p>Generic</p><ul><li><p><code>GenPoly{T}</code> (<code>GenPolyRing{T}</code>)</p></li><li><p><code>GenRelSeries{T}</code> (<code>GenRelSeriesRing{T}</code>)</p></li><li><p><code>GenRes{T}</code> (<code>GenResRing{T}</code>)</p></li><li><p><code>GenFrac{T}</code> (<code>GenFracField{T}</code>)</p></li><li><p><code>GenMat{T}</code> (<code>GenMatSpace{T}</code>)</p></li></ul></li><li><p>Flint</p><ul><li><p><code>fmpz</code> (<code>FlintIntegerRing</code>)</p></li><li><p><code>fmpq</code> (<code>FlintRationalField</code>)</p></li><li><p><code>fq_nmod</code> (<code>FqNmodFiniteField</code>)</p></li><li><p><code>fq</code> (<code>FqFiniteField</code>)</p></li><li><p><code>padic</code> (<code>FlintPadicField</code>)</p></li><li><p><code>fmpz_poly</code> (<code>FmpzPolyRing</code>)</p></li><li><p><code>fmpq_poly</code> (<code>FmpqPolyRing</code>)</p></li><li><p><code>nmod_poly</code> (<code>NmodPolyRing</code>)</p></li><li><p><code>fmpz_mod_poly</code> (<code>FmpzModPolyRing</code>)</p></li><li><p><code>fq_poly</code> (<code>FqPolyRing</code>)</p></li><li><p><code>fq_nmod_poly</code> (<code>FqNmodPolyRing</code>)</p></li><li><p><code>fmpz_rel_series</code> (<code>FmpzRelSeriesRing</code>)</p></li><li><p><code>fmpq_rel_series</code> (<code>FmpqRelSeriesRing</code>)</p></li><li><p><code>fmpz_mod_rel_series</code> (<code>FmpzModRelSeriesRing</code>)</p></li><li><p><code>fq_nmod_rel_series</code> (<code>FqNmodRelSeriesRing</code>)</p></li><li><p><code>fq_rel_series</code> (<code>FqRelSeriesRing</code>)</p></li><li><p><code>fmpz_mat</code> (<code>FmpzMatSpace</code>)</p></li><li><p><code>nmod_mat</code> (<code>NmodMatSpace</code>)</p></li><li><p><code>perm</code> (<code>PermGroup</code>)</p></li></ul></li><li><p>Antic</p><ul><li><p><code>nf_elem</code> (<code>AnticNumberField</code>)</p></li></ul></li><li><p>Arb</p><ul><li><p><code>arb</code> (<code>ArbField</code>)</p></li><li><p><code>acb</code> (<code>AcbField</code>)</p></li></ul></li></ul><footer><hr/><a class="previous" href="about.html"><span class="direction">Previous</span><span class="title">Nemo</span></a><a class="next" href="constructors.html"><span class="direction">Next</span><span class="title">Constructing mathematical objects in Nemo</span></a></footer></article></body></html>
