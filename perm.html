<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Permutation groups · AbstractAlgebra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractAlgebra.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">AbstractAlgebra.jl</a></li><li><a class="toctext" href="constructors.html">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="rings.html">Ring Interface</a></li><li><a class="toctext" href="euclidean.html">Euclidean Ring Interface</a></li><li><a class="toctext" href="integer.html">Integer ring</a></li><li><a class="toctext" href="polynomial_rings.html">Univariate Polynomial Ring Interface</a></li><li><a class="toctext" href="polynomial.html">Generic univariate polynomials</a></li><li><a class="toctext" href="mpolynomial_rings.html">Multvariate Polynomial Ring Interface</a></li><li><a class="toctext" href="mpolynomial.html">Generic sparse distributed multivariate polynomials</a></li><li><a class="toctext" href="series_rings.html">Series Ring Interface</a></li><li><a class="toctext" href="series.html">Generic power series</a></li><li><a class="toctext" href="puiseux.html">Generic Puiseux series</a></li><li><a class="toctext" href="residue_rings.html">Residue Ring Interface</a></li><li><a class="toctext" href="residue.html">Generic residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li><a class="toctext" href="fields.html">Field Interface</a></li><li><a class="toctext" href="fraction_fields.html">Fraction Field Interface</a></li><li><a class="toctext" href="fraction.html">Generic fraction fields</a></li><li><a class="toctext" href="rational.html">Rational field</a></li><li><a class="toctext" href="finfield.html">Finite fields</a></li><li><a class="toctext" href="real.html">Real field</a></li><li><a class="toctext" href="numberfield.html">Number fields</a></li></ul></li><li><span class="toctext">Groups</span><ul><li class="current"><a class="toctext" href="perm.html">Permutation groups</a><ul class="internal"><li><a class="toctext" href="#Permutation-group-constructors-1">Permutation group constructors</a></li><li><a class="toctext" href="#Permutation-constructors-1">Permutation constructors</a></li><li><a class="toctext" href="#Basic-functionality-1">Basic functionality</a></li><li><a class="toctext" href="#Basic-manipulation-1">Basic manipulation</a></li><li><a class="toctext" href="#Arithmetic-operators-1">Arithmetic operators</a></li><li><a class="toctext" href="#Comparison-1">Comparison</a></li><li><a class="toctext" href="#Inversion-1">Inversion</a></li></ul></li></ul></li><li><a class="toctext" href="matrix_spaces.html">Matrix Interface</a></li><li><a class="toctext" href="matrix.html">Generic matrices</a></li><li><a class="toctext" href="types.html">Appendix A: Types in AbstractAlgebra.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li>Groups</li><li><a href="perm.html">Permutation groups</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/perm.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Permutation groups</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Permutation-groups-1" href="#Permutation-groups-1">Permutation groups</a></h1><p>AbstractAlgebra.jl provides rudimentary support for permutation groups. These are mainly used for permutations of rows of matrices.</p><p>Permutation groups are created using the <code>PermGroup</code> (inner) constructor. However, for convenience we define</p><pre><code class="language-none">PermutationGroup = PermGroup</code></pre><p>so that permutation groups can be created using <code>PermutationGroup</code> instead of <code>PermGroup</code>.</p><p>The types of permutations in AbstractAlgebra.jl are given by the following table, along with the libraries that provide them and the associated types of the parent objects.</p><table><tr><th>Library</th><th>Group</th><th>Element type</th><th>Parent type</th></tr><tr><td>Native</td><td><span>$S_n$</span></td><td><code>perm</code></td><td><code>PermGroup</code></td></tr></table><p>All the permutation group types belong to the <code>Group</code> abstract type and the corresponding permutation element types belong to the <code>GroupElem</code> abstract type.</p><h2><a class="nav-anchor" id="Permutation-group-constructors-1" href="#Permutation-group-constructors-1">Permutation group constructors</a></h2><p>In order to construct permutations in AbstractAlgebra.jl, one must first construct the permutation group they belong to. This is accomplished with the following constructor.</p><pre><code class="language-julia">PermGroup(n::Int)</code></pre><p>Construct the permutation group on <span>$n$</span> points. The function returns the parent object representing the group.</p><p><strong>Examples</strong></p><pre><code class="language-julia">G = PermutationGroup(5)

p = G()</code></pre><h2><a class="nav-anchor" id="Permutation-constructors-1" href="#Permutation-constructors-1">Permutation constructors</a></h2><p>Once a permutation group is constructed, there are various ways to construct permutations in that group.</p><p>Note that permutations consist of lists of <span>$n$</span> integers numbered from <span>$1$</span> to <span>$n$</span>. If the <span>$i$</span>-th entry of a permuation is <span>$j$</span>, this corresponds to sending <span>$i \to j$</span> in the permutation.</p><p><strong>Examples</strong></p><pre><code class="language-julia">G = PermutationGroup(5)

p = G()</code></pre><h2><a class="nav-anchor" id="Basic-functionality-1" href="#Basic-functionality-1">Basic functionality</a></h2><p>The following basic functionality is provided by the default permutation group implementation in AbstractAlgebra.jl, to support construction of other generic constructions over permutation groups. Any custom permutation group implementation in AbstractAlgebra.jl should provide these  functions along with the usual group element arithmetic.</p><pre><code class="language-julia">parent_type(::Type{perm})</code></pre><p>Gives the type of the parent object of a permutation group element.</p><pre><code class="language-julia">elem_type(R::PermGroup)</code></pre><p>Given the parent object for a permutation group, return the type of elements of the group.</p><pre><code class="language-julia">Base.hash(a::perm, h::UInt)</code></pre><p>Return a <code>UInt</code> hexadecimal hash of the permutation element <span>$a$</span>. This should be xor&#39;d with a fixed random hexadecimal specific to the permutation group type. The hash of the entries of the permutation should be xor&#39;d with the supplied parameter <code>h</code> as part of computing the hash.</p><pre><code class="language-julia">deepcopy(a::perm)</code></pre><p>Construct a copy of the given permutation group element and return it. This function must recursively construct copies of all of the internal data in the given element. AbstractAlgebra.jl permutation group elements are mutable and so returning shallow copies is not sufficient.</p><pre><code class="language-julia">getindex(a::perm, n::Int)</code></pre><p>Allows access to entry <span>$n$</span> of the given permutation via the syntax <code>a[n]</code>. Note that entries are <span>$1$</span>-indexed.</p><pre><code class="language-julia">setindex!(a::perm, d::Int, n::Int)</code></pre><p>Set the <span>$n$</span>-th entry of the given permutation to <span>$d$</span>. This allows Julia to provide the syntax <span>$a[n] = d$</span> for setting entries of a permuation. Note that entries are <span>$1$</span>-indexed.</p><p>Given the parent object <code>G</code> for a permutation group, the following coercion functions are provided to coerce various elements into the permutation group. Developers provide these by overloading the <code>call</code> operator for the permutation group parent objects.</p><pre><code class="language-julia">R()</code></pre><p>Return the identity permutation.</p><pre><code class="language-julia">R(A::Array{Int, 1})</code></pre><p>Return the permutation whose entries are given by the elements of the supplied vector.</p><pre><code class="language-julia">R(p::perm)</code></pre><p>Take a permutation that is already in the permutation group and simply return it. A copy of the original is not made.</p><p>In addition to the above, developers of custom permutation group types must ensure that each permutation element contains a field <code>parent</code> specifying the parent object of the permutation group element, or at least supply the equivalent of the function <code>parent(a::perm)</code> to return the parent object of a permutation group element.</p><h2><a class="nav-anchor" id="Basic-manipulation-1" href="#Basic-manipulation-1">Basic manipulation</a></h2><p>Numerous functions are provided to manipulate permutation group elements. Also see the section on basic functionality above.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parent-Tuple{AbstractAlgebra.Generic.perm}" href="#Base.parent-Tuple{AbstractAlgebra.Generic.perm}"><code>Base.parent</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">parent(a::perm)</code></pre><blockquote><p>Return the parent of the given permutation group element.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6c639f4b99014c80fc7513d142990058e0c30af0/src/generic/PermGroups.jl#L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.parity-Tuple{AbstractAlgebra.Generic.perm}" href="#AbstractAlgebra.Generic.parity-Tuple{AbstractAlgebra.Generic.perm}"><code>AbstractAlgebra.Generic.parity</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">parity(a::perm)</code></pre><blockquote><p>Return the parity of the given permutation, i.e. the parity of the number of transpositions that compose it. The function returns <span>$1$</span> if the parity is odd and <span>$0$</span> otherwise. By default <code>parity</code> will uses the cycle decomposition if it is already available, but will not compute it on demand. If You intend to use parity, or the cycle decomposition of a permutation later You may force <code>parity</code> to compute the cycle structure by calling <code>parity(a, Val{:cycles})</code>`.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6c639f4b99014c80fc7513d142990058e0c30af0/src/generic/PermGroups.jl#L54">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">G = PermutationGroup(5)

p = G([1, 3, 5, 2, 4])

R = parent(p)
a = parity(p)</code></pre><h2><a class="nav-anchor" id="Arithmetic-operators-1" href="#Arithmetic-operators-1">Arithmetic operators</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{AbstractAlgebra.Generic.perm,AbstractAlgebra.Generic.perm}" href="#Base.:*-Tuple{AbstractAlgebra.Generic.perm,AbstractAlgebra.Generic.perm}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">*(a::perm, b::perm)</code></pre><blockquote><p>Return the composition of the two permutations, i.e. <span>$a\circ b$</span>. In other words, the permutation corresponding to applying <span>$b$</span> first, then <span>$a$</span>, is returned.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6c639f4b99014c80fc7513d142990058e0c30af0/src/generic/PermGroups.jl#L215">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">G = PermutationGroup(5)

p = G([1, 3, 5, 2, 4])
q = G([5, 4, 1, 3, 2])

a = p*q</code></pre><h2><a class="nav-anchor" id="Comparison-1" href="#Comparison-1">Comparison</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{AbstractAlgebra.Generic.perm,AbstractAlgebra.Generic.perm}" href="#Base.:==-Tuple{AbstractAlgebra.Generic.perm,AbstractAlgebra.Generic.perm}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">==(a::perm, b::perm)</code></pre><blockquote><p>Return <code>true</code> if the given permutations are equal, otherwise return <code>false</code>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6c639f4b99014c80fc7513d142990058e0c30af0/src/generic/PermGroups.jl#L199">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">G = PermutationGroup(5)

p = G([1, 3, 5, 2, 4])
q = G([5, 4, 1, 3, 2])

p == q</code></pre><h2><a class="nav-anchor" id="Inversion-1" href="#Inversion-1">Inversion</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{AbstractAlgebra.Generic.perm}" href="#Base.inv-Tuple{AbstractAlgebra.Generic.perm}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">inv(a::perm)</code></pre><blockquote><p>Return the inverse of the given permutation, i.e. the permuation <span>$a^{-1}$</span> such that <span>$a\circ a^{-1} = a^{-1}\circ a$</span> is the identity permutation.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6c639f4b99014c80fc7513d142990058e0c30af0/src/generic/PermGroups.jl#L300">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">G = PermutationGroup(5)

p = G([1, 3, 5, 2, 4])

a = inv(p)</code></pre><footer><hr/><a class="previous" href="numberfield.html"><span class="direction">Previous</span><span class="title">Number fields</span></a><a class="next" href="matrix_spaces.html"><span class="direction">Next</span><span class="title">Matrix Interface</span></a></footer></article></body></html>
